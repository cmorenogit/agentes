import { Octokit } from '@octokit/rest';
import { AnalysisResult } from '../agent/analyzer.js';

export class PRCommenter {
  private octokit: Octokit;
  private owner: string;
  private repo: string;

  constructor(githubToken: string, owner: string, repo: string) {
    this.octokit = new Octokit({ auth: githubToken });
    this.owner = owner;
    this.repo = repo;
  }

  formatAnalysisComment(results: Map<string, AnalysisResult>, runUrl?: string): string {
    const totalFiles = results.size;
    const avgScore = Array.from(results.values()).reduce((sum, r) => sum + r.score, 0) / totalFiles;
    const totalCritical = Array.from(results.values()).reduce((sum, r) => sum + r.critical.length, 0);
    const totalWarnings = Array.from(results.values()).reduce((sum, r) => sum + r.warnings.length, 0);
    const totalSuggestions = Array.from(results.values()).reduce((sum, r) => sum + r.suggestions.length, 0);

    // Calculate estimated fix time
    const estimatedTime = totalCritical * 5 + totalWarnings * 3 + totalSuggestions * 2;

    let comment = `## üîç Supabase SQL Schema Analysis\n\n`;

    // Executive Summary Section
    comment += `### üìä Executive Summary\n\n`;
    comment += `| Metric | Value |\n`;
    comment += `|--------|-------|\n`;
    comment += `| Files Analyzed | ${totalFiles} |\n`;
    comment += `| Overall Score | **${avgScore.toFixed(1)}/10** |\n`;
    comment += `| üö® Critical Issues | ${totalCritical} |\n`;
    comment += `| ‚ö†Ô∏è Warnings | ${totalWarnings} |\n`;
    comment += `| ‚ÑπÔ∏è Suggestions | ${totalSuggestions} |\n`;
    comment += `| ‚è±Ô∏è Est. Fix Time | ~${estimatedTime} min |\n\n`;

    // Status Badge
    if (totalCritical > 0) {
      comment += `> **üö® ACTION REQUIRED** - ${totalCritical} critical issue(s) must be resolved before merging\n\n`;
    } else if (totalWarnings > 0) {
      comment += `> **‚úÖ READY** - No critical issues, ${totalWarnings} warning(s) to consider\n\n`;
    } else {
      comment += `> **üéâ EXCELLENT** - All files follow Supabase best practices!\n\n`;
    }

    if (runUrl) {
      comment += `[üìã View detailed report in GitHub Actions](${runUrl})\n\n`;
    }

    comment += `---\n\n`;

    // Analyze each file
    for (const [filename, result] of results) {
      comment += this.formatFileAnalysis(filename, result);
      comment += `\n---\n\n`;
    }

    comment += `*Analysis powered by Claude AI | Generated by [Supabase SQL Agent](https://github.com/${this.owner}/${this.repo})*`;

    return comment;
  }

  private formatFileAnalysis(filename: string, result: AnalysisResult): string {
    let section = `### üìÑ \`${filename}\` - Score: **${result.score}/10**\n\n`;

    section += `**Summary:** ${result.summary}\n\n`;

    // Critical Issues
    if (result.critical.length > 0) {
      section += `#### üö® Critical Issues (${result.critical.length})\n\n`;
      result.critical.forEach((issue, idx) => {
        section += `**${idx + 1}.** ${issue.line ? `Line ${issue.line}: ` : ''}${issue.issue}\n`;
        section += `- **Risk:** ${issue.risk}\n`;
        section += `- **Fix:**\n\`\`\`sql\n${issue.fix}\n\`\`\`\n\n`;
      });
    }

    // Warnings
    if (result.warnings.length > 0) {
      section += `#### ‚ö†Ô∏è Warnings (${result.warnings.length})\n\n`;
      result.warnings.forEach((warning, idx) => {
        section += `**${idx + 1}.** ${warning.line ? `Line ${warning.line}: ` : ''}${warning.issue}\n`;
        section += `- **Impact:** ${warning.impact}\n`;
        section += `- **Fix:**\n\`\`\`sql\n${warning.fix}\n\`\`\`\n\n`;
      });
    }

    // Suggestions
    if (result.suggestions.length > 0) {
      section += `#### ‚ÑπÔ∏è Suggestions (${result.suggestions.length})\n\n`;
      result.suggestions.forEach((suggestion, idx) => {
        section += `**${idx + 1}.** ${suggestion.line ? `Line ${suggestion.line}: ` : ''}${suggestion.suggestion}\n`;
        section += `- **Benefit:** ${suggestion.benefit}\n`;
        section += `- **Implementation:**\n\`\`\`sql\n${suggestion.fix}\n\`\`\`\n\n`;
      });
    }

    // Good Practices
    if (result.goodPractices.length > 0) {
      section += `#### ‚úÖ Good Practices Found\n\n`;
      result.goodPractices.forEach((practice) => {
        section += `- ${practice}\n`;
      });
      section += `\n`;
    }

    // Action Plan
    if (result.actionPlan.length > 0) {
      section += `#### üìã Action Plan\n\n`;
      result.actionPlan.forEach((action) => {
        section += `${action}\n`;
      });
      section += `\n`;
    }

    return section;
  }

  async postComment(prNumber: number, results: Map<string, AnalysisResult>, runUrl?: string): Promise<void> {
    const comment = this.formatAnalysisComment(results, runUrl);

    try {
      await this.octokit.issues.createComment({
        owner: this.owner,
        repo: this.repo,
        issue_number: prNumber,
        body: comment,
      });

      console.log(`‚úÖ Comment posted to PR #${prNumber}`);
    } catch (error) {
      console.error('‚ùå Error posting comment:', error);
      throw error;
    }
  }
}
