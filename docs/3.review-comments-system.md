# Sistema de Comentarios por Alerta con Re-evaluaci√≥n

## üìã Resumen Ejecutivo

Este documento analiza c√≥mo implementar un sistema de comentarios granulares en l√≠neas espec√≠ficas de c√≥digo SQL dentro de Pull Requests de GitHub, con capacidad de re-evaluaci√≥n autom√°tica cuando los desarrolladores responden a las alertas.

**Objetivo:** Mejorar la experiencia de revisi√≥n permitiendo comentarios contextuales en l√≠neas espec√≠ficas y re-an√°lisis dirigido de alertas individuales.

---

## üèóÔ∏è An√°lisis de Estructura Actual

### Estado Actual del Sistema

**Arquitectura existente:**
```typescript
// src/github/commenter.ts (l√≠nea 124-130)
async postComment(prNumber, results, runUrl, aiModel, modelVersion) {
  const comment = this.formatAnalysisComment(results, runUrl, aiModel, modelVersion);

  await this.octokit.issues.createComment({
    owner: this.owner,
    repo: this.repo,
    issue_number: prNumber,
    body: comment
  });
}
```

**Caracter√≠sticas actuales:**
- ‚úÖ 3 modelos analizan en paralelo (Claude, GPT-5, Gemini)
- ‚úÖ 3 comentarios separados por modelo
- ‚úÖ Formato detallado con executive summary
- ‚úÖ Categorizaci√≥n: critical, warnings, suggestions
- ‚úÖ Good practices identificadas

**Limitaciones detectadas:**
- ‚ùå Usa `issues.createComment()` ‚Üí comentarios generales en conversaci√≥n PR
- ‚ùå Sin vinculaci√≥n alerta ‚Üí l√≠nea espec√≠fica de c√≥digo
- ‚ùå Sin persistencia de estado para re-evaluaci√≥n
- ‚ùå Sin webhooks para detectar respuestas de desarrolladores
- ‚ùå Re-an√°lisis completo o nada (no granular)
- ‚ùå UX: scroll largo para encontrar alerta espec√≠fica

---

## üîç Comparaci√≥n: Tipos de Comentarios en GitHub

### 1. Issue Comments (Actual)

**API utilizada actualmente:**
```typescript
await octokit.issues.createComment({
  owner: 'owner',
  repo: 'repo',
  issue_number: 123,
  body: 'Comentario completo del an√°lisis'
});
```

**Caracter√≠sticas:**
- Comentario general en conversaci√≥n del PR
- NO vinculado a l√≠nea espec√≠fica
- NO parte de review formal
- Visible en pesta√±a "Conversation"
- NO permite comentarios en l√≠nea

**Cu√°ndo usar:**
- Resumen ejecutivo general
- Alertas sin l√≠nea espec√≠fica
- M√©tricas globales

### 2. Review Comments (Propuesto)

**API propuesta:**
```typescript
await octokit.pulls.createReviewComment({
  owner: 'owner',
  repo: 'repo',
  pull_number: 123,
  commit_id: 'sha256...',    // Commit espec√≠fico
  path: 'sql/schema.sql',    // Archivo
  line: 42,                  // L√≠nea espec√≠fica
  side: 'RIGHT',             // Lado del diff
  body: 'üö® Critical: API key sin hash'
});
```

**Caracter√≠sticas:**
- ‚úÖ Comentario en l√≠nea espec√≠fica de c√≥digo
- ‚úÖ Vinculado a commit SHA
- ‚úÖ Threaded responses (conversaciones)
- ‚úÖ Visible en pesta√±a "Files changed"
- ‚úÖ `comment_id` persistente para tracking
- ‚úÖ Soporta replies con `in_reply_to_id`

**Cu√°ndo usar:**
- Alertas critical/warning con l√≠nea conocida
- Issues espec√≠ficos en sintaxis SQL
- Sugerencias de refactoring puntuales

### 3. Pull Request Reviews (Propuesto Batch)

**API m√°s eficiente:**
```typescript
await octokit.pulls.createReview({
  owner: 'owner',
  repo: 'repo',
  pull_number: 123,
  commit_id: 'sha256...',
  event: 'COMMENT',        // o 'APPROVE'/'REQUEST_CHANGES'
  body: 'Review summary',  // Comentario general del review
  comments: [              // Array de comentarios en l√≠nea
    { path: 'sql/schema.sql', line: 42, body: 'Alert 1' },
    { path: 'sql/users.sql', line: 15, body: 'Alert 2' },
    { path: 'sql/orders.sql', line: 88, body: 'Alert 3' }
  ]
});
```

**Caracter√≠sticas:**
- ‚úÖ Batch: m√∫ltiples comentarios en 1 API call
- ‚úÖ Agrupa comentarios bajo 1 review
- ‚úÖ M√°s eficiente para rate limits
- ‚úÖ Review puede tener estado (COMMENT/APPROVE/REQUEST_CHANGES)
- ‚úÖ M√°ximo 30 comentarios por review

**Cu√°ndo usar:**
- M√∫ltiples alertas en el mismo an√°lisis
- Optimizaci√≥n de rate limits
- Review formal con aprobaci√≥n/rechazo

---

## üéØ Arquitectura Propuesta

### Componentes Nuevos

```
src/
‚îú‚îÄ‚îÄ github/
‚îÇ   ‚îú‚îÄ‚îÄ review-commenter.ts       # Gesti√≥n de review comments
‚îÇ   ‚îú‚îÄ‚îÄ metadata-store.ts         # Persistencia de metadata en Gist
‚îÇ   ‚îî‚îÄ‚îÄ commenter.ts              # Mantener para summary general
‚îú‚îÄ‚îÄ reevaluate.ts                 # Script de re-evaluaci√≥n
‚îî‚îÄ‚îÄ index.ts                      # Modificar flujo principal

.github/workflows/
‚îú‚îÄ‚îÄ sql-review.yml                # Modificar: usar review comments
‚îî‚îÄ‚îÄ reevaluate-alert.yml          # Nuevo: listener de webhooks
```

### Flujo de Datos

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant GH as GitHub
    participant Action as GitHub Action
    participant Bot as SQL Agent Bot
    participant Gist as Gist Storage

    Dev->>GH: Create PR with SQL changes
    GH->>Action: Trigger sql-review.yml
    Action->>Bot: Analyze SQL files
    Bot->>Bot: Run 3 AI models in parallel

    loop For each alert with line number
        Bot->>GH: createReview() with comments batch
        GH-->>Bot: Return comment_id
        Bot->>Gist: Store comment_id ‚Üí alert mapping
    end

    Bot->>GH: Post summary comment with gist_id

    Dev->>GH: Reply to review comment
    GH->>Action: Webhook: pull_request_review_comment
    Action->>Gist: Load metadata by gist_id
    Gist-->>Action: Return alert data
    Action->>Bot: Re-evaluate specific alert
    Bot->>Bot: Re-analyze SQL file
    Bot->>GH: Update review comment (resolved/persists)
    Bot->>Gist: Update last_evaluated timestamp
```

---

## üíæ Gesti√≥n de Estado y Persistencia

### Problema: GitHub Actions es Stateless

GitHub Actions no mantiene estado entre ejecuciones. Para re-evaluaci√≥n necesitamos persistir:

```typescript
interface CommentMetadata {
  comment_id: number;           // ID del comentario en GitHub
  pr_number: number;
  repository: string;
  alert: {
    type: 'critical' | 'warning' | 'suggestion';
    file: string;               // sql/schema.sql
    line: number;               // L√≠nea en archivo
    ai_model: string;           // claude-sonnet-4-5-20250929
    original_analysis: {        // An√°lisis original completo
      issue: string;
      risk: string;
      fix: string;
      table?: string;
      location?: string;
      present_in_file: boolean;
      confidence: number;
    };
  };
  created_at: string;           // ISO timestamp
  last_evaluated: string;       // ISO timestamp
  status: 'pending' | 'resolved' | 'persists';
}
```

### Opci√≥n A: Gist Privado (Recomendada para MVP)

**Ventajas:**
- ‚úÖ API nativa de GitHub (Octokit)
- ‚úÖ Sin infraestructura adicional
- ‚úÖ Privado por defecto
- ‚úÖ Control de versiones autom√°tico
- ‚úÖ F√°cil de implementar

**Desventajas:**
- ‚ùå L√≠mite 10MB por archivo
- ‚ùå No ACID (race conditions posibles)
- ‚ùå No queries complejas
- ‚ùå Performance degrada con muchos registros

**Implementaci√≥n:**

```typescript
// src/github/metadata-store.ts
import { Octokit } from '@octokit/rest';

export class MetadataStore {
  private octokit: Octokit;

  constructor(githubToken: string) {
    this.octokit = new Octokit({ auth: githubToken });
  }

  /**
   * Guarda metadata de an√°lisis en Gist privado
   * Retorna gist_id para referencia
   */
  async saveMetadata(
    prNumber: number,
    repository: string,
    metadata: Map<number, CommentMetadata>
  ): Promise<string> {
    const content = JSON.stringify(
      Object.fromEntries(metadata),
      null,
      2
    );

    const { data: gist } = await this.octokit.gists.create({
      files: {
        [`pr-${prNumber}-metadata.json`]: {
          content
        }
      },
      description: `SQL Analysis Metadata for ${repository}#${prNumber}`,
      public: false
    });

    console.log(`‚úÖ Metadata saved to Gist: ${gist.id}`);
    return gist.id;
  }

  /**
   * Carga metadata desde Gist
   */
  async loadMetadata(gistId: string): Promise<Map<number, CommentMetadata>> {
    const { data: gist } = await this.octokit.gists.get({
      gist_id: gistId
    });

    const filename = Object.keys(gist.files)[0];
    const content = gist.files[filename]?.content;

    if (!content) {
      throw new Error(`No content found in gist ${gistId}`);
    }

    const obj = JSON.parse(content);

    return new Map(
      Object.entries(obj).map(([k, v]) =>
        [parseInt(k), v as CommentMetadata]
      )
    );
  }

  /**
   * Actualiza metadata de un comentario espec√≠fico
   */
  async updateMetadata(
    gistId: string,
    commentId: number,
    updates: Partial<CommentMetadata>
  ): Promise<void> {
    const metadata = await this.loadMetadata(gistId);
    const existing = metadata.get(commentId);

    if (!existing) {
      throw new Error(`Comment ${commentId} not found in metadata`);
    }

    metadata.set(commentId, { ...existing, ...updates });

    // Re-guardar todo el gist
    const content = JSON.stringify(
      Object.fromEntries(metadata),
      null,
      2
    );

    await this.octokit.gists.update({
      gist_id: gistId,
      files: {
        [`pr-${existing.pr_number}-metadata.json`]: {
          content
        }
      }
    });

    console.log(`‚úÖ Updated metadata for comment ${commentId}`);
  }

  /**
   * Busca metadata por comment_id espec√≠fico
   */
  async getCommentMetadata(
    gistId: string,
    commentId: number
  ): Promise<CommentMetadata | undefined> {
    const metadata = await this.loadMetadata(gistId);
    return metadata.get(commentId);
  }
}
```

**Formato Gist:**
```json
{
  "123456": {
    "comment_id": 123456,
    "pr_number": 45,
    "repository": "owner/repo",
    "alert": {
      "type": "critical",
      "file": "sql/schema.sql",
      "line": 42,
      "ai_model": "claude-sonnet-4-5-20250929",
      "original_analysis": {
        "issue": "Inbound API key sin hash",
        "risk": "Exposici√≥n de credenciales",
        "fix": "ALTER TABLE ...",
        "table": "user_api_keys",
        "present_in_file": true,
        "confidence": 100
      }
    },
    "created_at": "2025-10-30T10:00:00Z",
    "last_evaluated": "2025-10-30T10:00:00Z",
    "status": "pending"
  },
  "123457": {
    ...
  }
}
```

### Opci√≥n B: Supabase Database (Producci√≥n)

**Ventajas:**
- ‚úÖ ACID compliant
- ‚úÖ Queries SQL complejas
- ‚úÖ Escalabilidad ilimitada
- ‚úÖ Triggers y funciones
- ‚úÖ Tiempo real

**Desventajas:**
- ‚ùå Infraestructura adicional
- ‚ùå Costos hosting
- ‚ùå Complejidad setup

**Schema:**
```sql
CREATE TABLE comment_metadata (
  comment_id BIGINT PRIMARY KEY,
  pr_number INT NOT NULL,
  repository TEXT NOT NULL,
  alert_type TEXT CHECK (alert_type IN ('critical', 'warning', 'suggestion')),
  file_path TEXT NOT NULL,
  line_number INT NOT NULL,
  ai_model TEXT NOT NULL,
  original_analysis JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  last_evaluated TIMESTAMPTZ DEFAULT now(),
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'resolved', 'persists')),

  INDEX idx_pr_number (pr_number),
  INDEX idx_repository (repository),
  INDEX idx_status (status)
);

CREATE TABLE reevaluation_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  comment_id BIGINT REFERENCES comment_metadata(comment_id),
  evaluated_at TIMESTAMPTZ DEFAULT now(),
  result TEXT CHECK (result IN ('resolved', 'persists', 'error')),
  details JSONB
);
```

---

## üîÑ Flujo Detallado: An√°lisis Inicial

### Paso 1: Detecci√≥n de Cambios

```typescript
// src/index.ts (mantener igual)
const prHandler = new PRHandler(config.githubToken, owner, repo);
const changedFiles = await prHandler.getChangedSQLFiles(config.prNumber);

// Obtener commit SHA m√°s reciente
const { data: pr } = await octokit.pulls.get({
  owner,
  repo,
  pull_number: config.prNumber
});
const commitId = pr.head.sha;  // Necesario para review comments
```

### Paso 2: An√°lisis Multi-Modelo

```typescript
// src/index.ts (mantener igual)
const [anthropicResults, openaiResults, geminiResults] = await Promise.all([
  anthropicAnalyzer.analyzeMultipleFiles(filesToAnalyze),
  openaiAnalyzer.analyzeMultipleFiles(filesToAnalyze),
  geminiAnalyzer.analyzeMultipleFiles(filesToAnalyze)
]);
```

### Paso 3: Creaci√≥n de Review Comments

```typescript
// src/github/review-commenter.ts
export class ReviewCommenter {
  private octokit: Octokit;
  private owner: string;
  private repo: string;

  constructor(githubToken: string, owner: string, repo: string) {
    this.octokit = new Octokit({ auth: githubToken });
    this.owner = owner;
    this.repo = repo;
  }

  /**
   * Crea review comments en batch (m√°x 30 por review)
   * Retorna Map de (file:line) ‚Üí comment_id
   */
  async postAlertsAsReview(
    prNumber: number,
    commitId: string,
    alerts: Array<{
      file: string;
      line: number;
      alert: CriticalIssue | Warning | Suggestion;
      type: 'critical' | 'warning' | 'suggestion';
      aiModel: string;
    }>
  ): Promise<Map<string, number>> {
    const BATCH_SIZE = 30;  // L√≠mite GitHub API
    const mapping = new Map<string, number>();

    for (let i = 0; i < alerts.length; i += BATCH_SIZE) {
      const batch = alerts.slice(i, i + BATCH_SIZE);

      const { data: review } = await this.octokit.pulls.createReview({
        owner: this.owner,
        repo: this.repo,
        pull_number: prNumber,
        commit_id: commitId,
        event: 'COMMENT',
        body: i === 0 ? this.formatReviewSummary(alerts, aiModel) : undefined,
        comments: batch.map(({ file, line, alert, type }) => ({
          path: file,
          line,
          body: this.formatAlert(alert, type)
        }))
      });

      // Mapear alerts ‚Üí comment IDs
      review.comments?.forEach((comment, idx) => {
        const original = batch[idx];
        const key = `${original.file}:${original.line}`;
        mapping.set(key, comment.id);
      });

      console.log(`‚úÖ Created review batch ${i / BATCH_SIZE + 1} with ${batch.length} comments`);
    }

    return mapping;
  }

  private formatAlert(
    alert: CriticalIssue | Warning | Suggestion,
    type: 'critical' | 'warning' | 'suggestion'
  ): string {
    const icon = type === 'critical' ? 'üö®' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
    const title = type === 'critical' ? 'Critical Issue' :
                  type === 'warning' ? 'Warning' : 'Suggestion';

    let body = `### ${icon} ${title}\n\n`;

    if ('issue' in alert) {
      body += `**Problem:** ${alert.issue}\n`;
      body += `**Risk:** ${alert.risk}\n\n`;
    } else if ('suggestion' in alert) {
      body += `**Suggestion:** ${alert.suggestion}\n`;
      body += `**Benefit:** ${alert.benefit}\n\n`;
    }

    if (alert.fix) {
      body += `**Suggested Fix:**\n\`\`\`sql\n${alert.fix}\n\`\`\`\n\n`;
    }

    if ('table' in alert && alert.table) {
      body += `**Table:** \`${alert.table}\`\n`;
    }

    if ('location' in alert && alert.location) {
      body += `**Location:** \`${alert.location}\`\n`;
    }

    if ('confidence' in alert && alert.confidence !== undefined) {
      body += `**Confidence:** ${alert.confidence}%\n`;
    }

    body += `\n---\n`;
    body += `üí¨ **Reply to this comment to trigger re-evaluation**\n`;
    body += `üîÑ Last checked: ${new Date().toISOString()}`;

    return body;
  }

  private formatReviewSummary(alerts: any[], aiModel: string): string {
    const critical = alerts.filter(a => a.type === 'critical').length;
    const warnings = alerts.filter(a => a.type === 'warning').length;
    const suggestions = alerts.filter(a => a.type === 'suggestion').length;

    return `## üîç SQL Analysis by ${aiModel}

**Summary:**
- üö® ${critical} Critical Issues
- ‚ö†Ô∏è ${warnings} Warnings
- ‚ÑπÔ∏è ${suggestions} Suggestions

Each alert is commented on the specific line. Reply to any comment to trigger re-evaluation.`;
  }

  /**
   * Actualiza un review comment existente
   */
  async updateReviewComment(
    commentId: number,
    status: 'resolved' | 'persists',
    newAnalysis?: any
  ): Promise<void> {
    const { data: comment } = await this.octokit.pulls.getReviewComment({
      owner: this.owner,
      repo: this.repo,
      comment_id: commentId
    });

    let updatedBody = comment.body;

    if (status === 'resolved') {
      updatedBody = `~~${comment.body}~~\n\n‚úÖ **Re-evaluated:** Issue resolved!\n\n*Last checked: ${new Date().toISOString()}*`;
    } else if (status === 'persists' && newAnalysis) {
      updatedBody = `${comment.body}\n\n‚ö†Ô∏è **Re-evaluated:** Issue still present\n\n${this.formatAlert(newAnalysis, 'warning')}\n\n*Last checked: ${new Date().toISOString()}*`;
    }

    await this.octokit.pulls.updateReviewComment({
      owner: this.owner,
      repo: this.repo,
      comment_id: commentId,
      body: updatedBody
    });

    console.log(`‚úÖ Updated comment ${commentId} with status: ${status}`);
  }
}
```

### Paso 4: Construcci√≥n de Metadata

```typescript
// src/index.ts (modificar)
const reviewCommenter = new ReviewCommenter(config.githubToken, owner, repo);
const metadataStore = new MetadataStore(config.githubToken);

// Recolectar alertas de todos los modelos
const allAlerts: Array<{
  file: string;
  line: number;
  alert: CriticalIssue | Warning | Suggestion;
  type: 'critical' | 'warning' | 'suggestion';
  aiModel: string;
}> = [];

// Claude
for (const [filename, result] of anthropicResults) {
  result.critical.forEach(c => {
    if (c.line) {
      allAlerts.push({
        file: filename,
        line: c.line,
        alert: c,
        type: 'critical',
        aiModel: 'claude-sonnet-4-5-20250929'
      });
    }
  });
  result.warnings.forEach(w => {
    if (w.line) {
      allAlerts.push({
        file: filename,
        line: w.line,
        alert: w,
        type: 'warning',
        aiModel: 'claude-sonnet-4-5-20250929'
      });
    }
  });
  // Repetir para suggestions...
}

// Repetir para OpenAI y Gemini...

// Crear review comments
const commentIdMap = await reviewCommenter.postAlertsAsReview(
  config.prNumber,
  commitId,
  allAlerts
);

// Construir metadata
const metadata = new Map<number, CommentMetadata>();

for (const [key, commentId] of commentIdMap) {
  const [file, lineStr] = key.split(':');
  const line = parseInt(lineStr);

  const alert = allAlerts.find(a =>
    a.file === file && a.line === line
  );

  if (alert) {
    metadata.set(commentId, {
      comment_id: commentId,
      pr_number: config.prNumber,
      repository: config.repository,
      alert: {
        type: alert.type,
        file: alert.file,
        line: alert.line,
        ai_model: alert.aiModel,
        original_analysis: alert.alert
      },
      created_at: new Date().toISOString(),
      last_evaluated: new Date().toISOString(),
      status: 'pending'
    });
  }
}

// Persistir metadata
const gistId = await metadataStore.saveMetadata(
  config.prNumber,
  config.repository,
  metadata
);

console.log(`‚úÖ Metadata saved to Gist: ${gistId}`);
```

### Paso 5: Comentario Summary con Referencia

```typescript
// Mantener comentario general con link a metadata
await commenter.postComment(
  config.prNumber,
  anthropicResults,
  runUrl,
  'Claude Sonnet 4.5',
  'claude-sonnet-4-5-20250929',
  gistId  // Nuevo par√°metro
);

// Modificar formatAnalysisComment() en commenter.ts:
formatAnalysisComment(..., gistId?: string): string {
  let comment = `## üîç Supabase SQL Schema Analysis\n\n`;

  // ... contenido existente ...

  if (gistId) {
    comment += `\n\n---\n\n`;
    comment += `üìã **Review Comments Metadata:** [View Gist](https://gist.github.com/${gistId})\n`;
    comment += `<!-- METADATA_GIST_ID: ${gistId} -->`;
  }

  return comment;
}
```

---

## üîÅ Flujo Detallado: Re-evaluaci√≥n

### Paso 1: Webhook Listener

```yaml
# .github/workflows/reevaluate-alert.yml
name: Re-evaluate SQL Alert

on:
  pull_request_review_comment:
    types: [created]

jobs:
  reevaluate:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build TypeScript
        run: npm run build

      - name: Check if reply to bot
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment;

            // Verificar si es respuesta a comentario del bot
            if (!comment.in_reply_to_id) {
              console.log('Not a reply to another comment');
              core.setOutput('should_reevaluate', 'false');
              return;
            }

            // Buscar metadata en comentarios del PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' &&
              c.body.includes('<!-- METADATA_GIST_ID:')
            );

            if (!botComment) {
              console.log('No metadata comment found');
              core.setOutput('should_reevaluate', 'false');
              return;
            }

            const gistMatch = botComment.body.match(/<!-- METADATA_GIST_ID: (\w+) -->/);
            if (!gistMatch) {
              console.log('No gist ID found in metadata comment');
              core.setOutput('should_reevaluate', 'false');
              return;
            }

            core.setOutput('gist_id', gistMatch[1]);
            core.setOutput('comment_id', comment.in_reply_to_id);
            core.setOutput('pr_number', context.payload.pull_request.number);
            core.setOutput('should_reevaluate', 'true');

      - name: Re-evaluate alert
        if: steps.check.outputs.should_reevaluate == 'true'
        run: npm run reevaluate
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GIST_ID: ${{ steps.check.outputs.gist_id }}
          COMMENT_ID: ${{ steps.check.outputs.comment_id }}
          PR_NUMBER: ${{ steps.check.outputs.pr_number }}
```

### Paso 2: Script de Re-evaluaci√≥n

```typescript
// src/reevaluate.ts
import { SQLAnalyzer } from './agent/analyzer.js';
import { OpenAIAnalyzer } from './agent/openai-analyzer.js';
import { GeminiAnalyzer } from './agent/gemini-analyzer.js';
import { MetadataStore } from './github/metadata-store.js';
import { ReviewCommenter } from './github/review-commenter.js';
import { SQLReader } from './parser/sql-reader.js';
import { Octokit } from '@octokit/rest';

async function reevaluateAlert() {
  console.log('üîÑ Starting alert re-evaluation...');

  // Cargar configuraci√≥n
  const githubToken = process.env.GITHUB_TOKEN!;
  const gistId = process.env.GIST_ID!;
  const commentId = parseInt(process.env.COMMENT_ID!);
  const prNumber = parseInt(process.env.PR_NUMBER!);
  const repository = process.env.GITHUB_REPOSITORY!;
  const [owner, repo] = repository.split('/');

  // Inicializar componentes
  const metadataStore = new MetadataStore(githubToken);
  const reviewCommenter = new ReviewCommenter(githubToken, owner, repo);
  const sqlReader = new SQLReader('sql');

  try {
    // 1. Cargar metadata del comentario
    console.log(`üìã Loading metadata for comment ${commentId}...`);
    const alertMeta = await metadataStore.getCommentMetadata(gistId, commentId);

    if (!alertMeta) {
      console.log('‚ùå No metadata found for this comment');
      return;
    }

    console.log(`‚úÖ Found alert: ${alertMeta.alert.type} in ${alertMeta.alert.file}:${alertMeta.alert.line}`);

    // 2. Re-leer archivo SQL
    console.log(`üìñ Reading SQL file: ${alertMeta.alert.file}`);
    const filename = alertMeta.alert.file.replace('sql/', '');
    const files = await sqlReader.readMultipleSQLFiles([filename]);

    if (files.length === 0) {
      console.log('‚ùå File not found or removed');
      return;
    }

    const sqlContent = files[0].content;

    // 3. Re-analizar con el modelo original
    console.log(`üîç Re-analyzing with ${alertMeta.alert.ai_model}...`);

    let newResult;
    if (alertMeta.alert.ai_model.includes('claude')) {
      const analyzer = new SQLAnalyzer(process.env.ANTHROPIC_API_KEY!);
      newResult = await analyzer.analyzeSQLFile(sqlContent, alertMeta.alert.file);
    } else if (alertMeta.alert.ai_model.includes('gpt')) {
      const analyzer = new OpenAIAnalyzer(process.env.OPENAI_API_KEY!);
      newResult = await analyzer.analyzeSQLFile(sqlContent, alertMeta.alert.file);
    } else if (alertMeta.alert.ai_model.includes('gemini')) {
      const analyzer = new GeminiAnalyzer(process.env.GEMINI_API_KEY!);
      newResult = await analyzer.analyzeSQLFile(sqlContent, alertMeta.alert.file);
    } else {
      throw new Error(`Unknown AI model: ${alertMeta.alert.ai_model}`);
    }

    // 4. Buscar si la alerta espec√≠fica sigue existiendo
    console.log('üîé Checking if alert still exists...');

    const allIssues = [
      ...newResult.critical,
      ...newResult.warnings,
      ...newResult.suggestions
    ];

    const originalIssue = alertMeta.alert.original_analysis.issue;
    const stillExists = allIssues.some(issue =>
      issue.line === alertMeta.alert.line &&
      issue.issue.toLowerCase().includes(originalIssue.toLowerCase().substring(0, 20))
    );

    // 5. Actualizar comentario seg√∫n resultado
    if (stillExists) {
      console.log('‚ö†Ô∏è Alert still present');
      await reviewCommenter.updateReviewComment(
        commentId,
        'persists',
        allIssues.find(i => i.line === alertMeta.alert.line)
      );

      await metadataStore.updateMetadata(gistId, commentId, {
        last_evaluated: new Date().toISOString(),
        status: 'persists'
      });
    } else {
      console.log('‚úÖ Alert resolved!');
      await reviewCommenter.updateReviewComment(
        commentId,
        'resolved'
      );

      await metadataStore.updateMetadata(gistId, commentId, {
        last_evaluated: new Date().toISOString(),
        status: 'resolved'
      });
    }

    console.log('‚ú® Re-evaluation complete!');

  } catch (error) {
    console.error('‚ùå Error during re-evaluation:', error);
    throw error;
  }
}

// Ejecutar si se llama directamente
if (import.meta.url === `file://${process.argv[1]}`) {
  reevaluateAlert();
}

export { reevaluateAlert };
```

### Paso 3: Script npm

```json
// package.json (agregar)
{
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "reevaluate": "node dist/reevaluate.js"
  }
}
```

---

## ‚ö° Rate Limits y Optimizaciones

### L√≠mites GitHub API

**Con `GITHUB_TOKEN` (GitHub Actions):**
- **1,000 requests/hora** por repositorio
- Cada review comment cuenta como 1 request
- `createReview()` batch cuenta como 1 request (¬°√≥ptimo!)

**Estrategia de optimizaci√≥n:**

```typescript
// ‚ùå INEFICIENTE: 1 API call por alerta
for (const alert of alerts) {
  await createReviewComment({
    path: alert.file,
    line: alert.line,
    body: alert.body
  });  // N llamadas (consume N requests)
}

// ‚úÖ EFICIENTE: 1 API call para hasta 30 alertas
await createReview({
  comments: alerts.slice(0, 30).map(a => ({
    path: a.file,
    line: a.line,
    body: a.body
  }))
});  // 1 llamada (consume 1 request)
```

**Batch processing:**

```typescript
const BATCH_SIZE = 30;  // L√≠mite impuesto por GitHub API

async function createReviewsInBatches(alerts) {
  const batches = [];

  for (let i = 0; i < alerts.length; i += BATCH_SIZE) {
    batches.push(alerts.slice(i, i + BATCH_SIZE));
  }

  for (const [index, batch] of batches.entries()) {
    console.log(`Creating review batch ${index + 1}/${batches.length}`);

    await octokit.pulls.createReview({
      owner, repo, pull_number: prNumber,
      commit_id: commitId,
      event: 'COMMENT',
      body: index === 0 ? 'SQL Analysis Results' : undefined,
      comments: batch.map(...)
    });

    // Opcional: delay entre batches para evitar throttling
    if (index < batches.length - 1) {
      await sleep(1000);  // 1 segundo
    }
  }
}
```

### Monitoreo de Rate Limits

```typescript
async function checkRateLimit(octokit: Octokit) {
  const { data: rateLimit } = await octokit.rateLimit.get();

  console.log(`Rate Limit Status:
    Remaining: ${rateLimit.rate.remaining}/${rateLimit.rate.limit}
    Resets at: ${new Date(rateLimit.rate.reset * 1000).toISOString()}
  `);

  if (rateLimit.rate.remaining < 100) {
    console.warn('‚ö†Ô∏è Low rate limit remaining!');
  }
}
```

---

## üöß Desaf√≠os T√©cnicos y Soluciones

### 1. Position vs Line en Diff

**Problema:** GitHub API tiene 2 sistemas de coordenadas:

```typescript
// Sistema 1: Line (simple, para single-line comments)
{
  line: 42,        // L√≠nea absoluta en archivo
  side: 'RIGHT'    // Lado del diff
}

// Sistema 2: Position (complejo, para multi-line)
{
  position: 8      // L√≠nea 8 en el DIFF, no en archivo
}
```

**Soluci√≥n:** Usar `line` + `commit_id` (m√°s simple):

```typescript
await octokit.pulls.createReviewComment({
  owner, repo, pull_number,
  commit_id: pr.head.sha,  // ‚Üê Requerido cuando usas 'line'
  path: 'sql/schema.sql',
  line: 42,                // ‚Üê L√≠nea absoluta
  side: 'RIGHT',
  body: 'Comment'
});
```

### 2. Comments en L√≠neas No Modificadas

**Problema:** Review comments solo funcionan en l√≠neas presentes en el diff.

**Escenario:**
```sql
-- L√≠nea 10 (no modificada)
CREATE TABLE users (id UUID);

-- L√≠nea 15 (modificada)
CREATE TABLE orders (tenant_id UUID);  -- ‚Üê Agregado
```

Si alerta est√° en l√≠nea 10 pero PR solo modific√≥ l√≠nea 15, el comment fallar√° con error `line is not in diff`.

**Soluci√≥n:**

```typescript
async function tryCreateReviewComment(commentData) {
  try {
    await octokit.pulls.createReviewComment(commentData);
  } catch (error) {
    if (error.message.includes('line is not in diff')) {
      console.log(`‚ö†Ô∏è Line ${commentData.line} not in diff, creating issue comment instead`);

      // Fallback: comentario general con referencia a l√≠nea
      await octokit.issues.createComment({
        owner, repo, issue_number: prNumber,
        body: `üìç **${commentData.path}:${commentData.line}**\n\n${commentData.body}`
      });
    } else {
      throw error;
    }
  }
}
```

### 3. Diff Drift (Commits Posteriores)

**Problema:** Si PR se actualiza con nuevos commits despu√©s del an√°lisis, las l√≠neas cambian.

**Escenario:**
```
Commit 1: An√°lisis en SHA abc123
  - Alerta en l√≠nea 42

Commit 2: Dev agrega c√≥digo, SHA def456
  - Alerta ahora est√° en l√≠nea 50
  - Comentario queda en SHA abc123 l√≠nea 42 (outdated)
```

**Soluci√≥n 1: Re-an√°lisis en cada push**

```yaml
# sql-review.yml
on:
  pull_request:
    types: [opened, synchronize]  # ‚Üê synchronize = nuevo push
    paths:
      - 'sql/**/*.sql'
```

**Soluci√≥n 2: Resoluci√≥n autom√°tica de outdated**

```typescript
async function resolveOutdatedComments(prNumber) {
  const { data: comments } = await octokit.pulls.listReviewComments({
    owner, repo, pull_number: prNumber
  });

  const outdatedComments = comments.filter(c =>
    c.user.type === 'Bot' &&
    c.outdated === true
  );

  for (const comment of outdatedComments) {
    await octokit.pulls.updateReviewComment({
      owner, repo,
      comment_id: comment.id,
      body: `~~${comment.body}~~\n\n‚ö†Ô∏è **Outdated:** Code changed after analysis. Please re-run analysis.`
    });
  }
}
```

### 4. M√∫ltiples Respuestas al Mismo Comentario

**Problema:** Dev puede responder m√∫ltiples veces al mismo comentario.

**Soluci√≥n: Throttling de re-evaluaciones**

```typescript
async function shouldReevaluate(commentId, metadata) {
  const alertMeta = await metadataStore.getCommentMetadata(gistId, commentId);

  if (!alertMeta) return false;

  // Verificar tiempo desde √∫ltima evaluaci√≥n
  const lastEval = new Date(alertMeta.last_evaluated);
  const now = new Date();
  const hoursSince = (now.getTime() - lastEval.getTime()) / 3600000;

  if (hoursSince < 1) {
    console.log('‚è≥ Re-evaluation throttled (less than 1 hour since last check)');
    return false;
  }

  return true;
}
```

### 5. Race Conditions en Gist Updates

**Problema:** M√∫ltiples webhooks simult√°neos actualizando mismo Gist.

**Soluci√≥n: Retry logic con exponential backoff**

```typescript
async function updateMetadataWithRetry(gistId, commentId, updates, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      await metadataStore.updateMetadata(gistId, commentId, updates);
      return;
    } catch (error) {
      if (attempt === maxRetries) throw error;

      const delay = Math.pow(2, attempt) * 1000;  // 2s, 4s, 8s
      console.log(`‚ö†Ô∏è Retry ${attempt}/${maxRetries} after ${delay}ms`);
      await sleep(delay);
    }
  }
}
```

---

## üìä Trade-offs y Decisiones de Dise√±o

### Review Comments vs Issue Comments

| Aspecto | Review Comments (Propuesto) | Issue Comments (Actual) |
|---------|----------------------------|------------------------|
| **UX** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Contextual, inline | ‚≠ê‚≠ê Scroll largo |
| **Precisi√≥n** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê L√≠nea exacta | ‚≠ê‚≠ê‚≠ê Solo texto |
| **Complejidad** | üî¥ Alta (webhooks, estado) | üü¢ Baja (ya funciona) |
| **Mantenimiento** | üî¥ 2 workflows | üü¢ 1 workflow |
| **Persistencia** | üî¥ Gist/DB necesario | üü¢ No necesita |
| **Re-evaluaci√≥n** | ‚úÖ Granular por alerta | ‚ùå Todo o nada |
| **Rate Limits** | üü° M√°s API calls | üü¢ Menos calls |
| **Costo** | üü° M√°s compute time | üü¢ Menos compute |
| **Dev Experience** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Interactivo | ‚≠ê‚≠ê Pasivo |

### Persistencia: Gist vs Supabase

| Aspecto | Gist (MVP) | Supabase (Producci√≥n) |
|---------|-----------|----------------------|
| **Setup** | üü¢ Inmediato | üî¥ Requiere infra |
| **Costo** | üü¢ Gratis | üü° Hosting fees |
| **Escalabilidad** | üü° 10MB limit | üü¢ Ilimitado |
| **Queries** | ‚ùå Solo JSON parse | ‚úÖ SQL complejo |
| **Atomicidad** | ‚ùå No ACID | ‚úÖ ACID |
| **Latencia** | üü¢ Low | üü° Network hop |

**Recomendaci√≥n:** Empezar con Gist, migrar a Supabase si >100 PRs/mes.

### Re-an√°lisis: Completo vs Parcial

| Aspecto | Completo | Parcial (Solo Alerta) |
|---------|---------|---------------------|
| **Precisi√≥n** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Detecta nuevos issues | ‚≠ê‚≠ê‚≠ê Solo verifica existente |
| **Velocidad** | üî¥ 30-60s | üü¢ 5-10s |
| **Costo API** | üî¥ 3 modelos full | üü¢ 1 modelo partial |
| **UX** | üü° Espera larga | üü¢ Respuesta r√°pida |

**Recomendaci√≥n:** Parcial para re-evaluaciones (UX > completitud).

---

## üéØ Plan de Implementaci√≥n

### Fase 1: Infraestructura Base (1 d√≠a)

**Tareas:**
- [ ] Crear `src/github/review-commenter.ts`
- [ ] Crear `src/github/metadata-store.ts`
- [ ] Crear tests unitarios b√°sicos
- [ ] Documentar APIs

**Criterio de √©xito:**
- Funciones pueden crear review comments
- Metadata se persiste en Gist
- Tests pasan al 100%

### Fase 2: Integraci√≥n con An√°lisis (1 d√≠a)

**Tareas:**
- [ ] Modificar `src/index.ts` para usar review comments
- [ ] Recolectar alertas de 3 modelos
- [ ] Crear reviews en batch
- [ ] Construir y persistir metadata
- [ ] Agregar referencia gistId en summary comment

**Criterio de √©xito:**
- PR con SQL cambios dispara reviews
- Comentarios aparecen en l√≠neas correctas
- Metadata accesible en Gist

### Fase 3: Webhook Re-evaluaci√≥n (1 d√≠a)

**Tareas:**
- [ ] Crear `.github/workflows/reevaluate-alert.yml`
- [ ] Crear `src/reevaluate.ts`
- [ ] Implementar detecci√≥n de replies a bot
- [ ] Re-an√°lisis parcial
- [ ] Actualizaci√≥n de comentarios

**Criterio de √©xito:**
- Dev reply dispara webhook
- Solo alerta espec√≠fica se re-eval√∫a
- Comentario se actualiza con resultado

### Fase 4: Optimizaciones (0.5 d√≠a)

**Tareas:**
- [ ] Implementar throttling de re-evaluaciones
- [ ] Retry logic para Gist updates
- [ ] Monitoreo de rate limits
- [ ] Fallback para l√≠neas no en diff

**Criterio de √©xito:**
- No race conditions
- Rate limits respetados
- Manejo robusto de errores

### Fase 5: Testing y Documentaci√≥n (0.5 d√≠a)

**Tareas:**
- [ ] Tests end-to-end con PR real
- [ ] Actualizar `PROJECT_OVERVIEW.md`
- [ ] Crear `docs/review-comments-usage.md`
- [ ] Video demo

**Criterio de √©xito:**
- Pipeline completo funciona
- Documentaci√≥n completa
- Equipo capacitado

---

## ü§î Preguntas Sin Resolver

### 1. Persistencia

**Pregunta:** ¬øUsar Gist privado o Supabase DB?

**Opciones:**
- **A. Gist** (recomendado para MVP)
  - Pro: setup inmediato, cero infra
  - Con: l√≠mite 10MB, no queries

- **B. Supabase**
  - Pro: escalable, SQL queries
  - Con: requiere setup, costos

**Recomendaci√≥n:** Empezar con Gist, migrar si >100 PRs/mes.

### 2. Re-an√°lisis en Pushes

**Pregunta:** ¬øRe-analizar autom√°ticamente en cada push al PR?

**Opciones:**
- **A. S√≠** (mantener comments actualizados)
  - Pro: comentarios siempre relevantes
  - Con: m√°s API calls, costo

- **B. No** (solo cuando dev responde)
  - Pro: menos costos
  - Con: comments pueden quedar outdated

**Recomendaci√≥n:** Opcional: solo si dev responde. Re-an√°lisis full opcional con comando `/reanalyze`.

### 3. M√∫ltiples Modelos

**Pregunta:** ¬øC√≥mo manejar 3 modelos con review comments?

**Opciones:**
- **A. 1 review por modelo** (3 reviews separados)
  - Pro: claridad, trazabilidad
  - Con: 3x API calls, UI saturada

- **B. 1 review combinado** (etiquetar modelo en body)
  - Pro: menos calls, UI limpia
  - Con: pierde separaci√≥n modelo

**Recomendaci√≥n:** Opci√≥n A (3 reviews). Agregar label con modelo en cada comment.

### 4. Alertas sin L√≠nea

**Pregunta:** ¬øQu√© hacer con alertas globales sin l√≠nea espec√≠fica?

**Opciones:**
- **A. Issue comment** (actual)
- **B. Review comment en l√≠nea 1** (artificial)
- **C. Ignorar** (solo inline)

**Recomendaci√≥n:** Opci√≥n A (fallback a issue comment con referencia).

### 5. Rate Limits

**Pregunta:** ¬øImplementar monitoreo proactivo de rate limits?

**Opciones:**
- **A. S√≠** (check antes de cada batch)
  - Pro: evita throttling
  - Con: 1 API call extra

- **B. No** (reactive)
  - Pro: menos calls
  - Con: puede fallar

**Recomendaci√≥n:** Opci√≥n A (log warning si <100 remaining).

### 6. Auto-Resoluci√≥n

**Pregunta:** ¬øAuto-resolver comments si nuevo push corrige issue?

**Opciones:**
- **A. S√≠** (re-an√°lisis autom√°tico en push)
  - Pro: UX fluida
  - Con: m√°s costos

- **B. No** (manual)
  - Pro: menos costos
  - Con: comments quedan pendientes

**Recomendaci√≥n:** Opci√≥n B (manual). Dev debe responder para disparar re-eval.

---

## üìö Referencias

### GitHub API Docs

- **Review Comments:** https://docs.github.com/en/rest/pulls/comments
- **Pull Request Reviews:** https://docs.github.com/en/rest/pulls/reviews
- **Webhooks:** https://docs.github.com/en/webhooks
- **Octokit:** https://octokit.github.io/rest.js/

### Ejemplos de C√≥digo

- **Review API Examples:** https://github.com/octokit/octokit.js/tree/main/examples
- **GitHub Actions Webhooks:** https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows

### Herramientas Similares

- **Danger.js** (review automation)
- **CodeRabbit** (AI code reviews)
- **Review Dog** (automated review comments)

---

## ‚úÖ Conclusi√≥n

El sistema de review comments proporciona una UX significativamente mejor para desarrolladores, permitiendo:

1. ‚úÖ Comentarios contextuales en l√≠neas espec√≠ficas
2. ‚úÖ Re-evaluaci√≥n granular por alerta
3. ‚úÖ Conversaciones threaded por issue
4. ‚úÖ Estado persistente para tracking

**Trade-off principal:** Mayor complejidad t√©cnica vs mejor experiencia de usuario.

**Recomendaci√≥n:** Implementar en fases, empezando con infraestructura base y Gist para MVP.

---

**Versi√≥n:** 1.0
**Fecha:** 2025-10-30
**Pr√≥xima revisi√≥n:** Despu√©s de implementar Fase 1
