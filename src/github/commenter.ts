import { Octokit } from '@octokit/rest';
import { AnalysisResult } from '../agent/analyzer.js';

export class PRCommenter {
  private octokit: Octokit;
  private owner: string;
  private repo: string;

  constructor(githubToken: string, owner: string, repo: string) {
    this.octokit = new Octokit({ auth: githubToken });
    this.owner = owner;
    this.repo = repo;
  }

  formatAnalysisComment(results: Map<string, AnalysisResult>): string {
    const totalFiles = results.size;
    const avgScore = Array.from(results.values()).reduce((sum, r) => sum + r.score, 0) / totalFiles;

    let comment = `## üîç Supabase SQL Schema Analysis\n\n`;
    comment += `**Files Analyzed:** ${totalFiles} | **Average Score:** ${avgScore.toFixed(1)}/10\n\n`;
    comment += `---\n\n`;

    // Analyze each file
    for (const [filename, result] of results) {
      comment += this.formatFileAnalysis(filename, result);
      comment += `\n---\n\n`;
    }

    // Overall summary
    const totalCritical = Array.from(results.values()).reduce((sum, r) => sum + r.critical.length, 0);
    const totalWarnings = Array.from(results.values()).reduce((sum, r) => sum + r.warnings.length, 0);

    if (totalCritical > 0) {
      comment += `### ‚ö†Ô∏è Overall Status: NEEDS ATTENTION\n\n`;
      comment += `Found **${totalCritical} critical issue(s)** that must be resolved before merging.\n\n`;
    } else if (totalWarnings > 0) {
      comment += `### ‚úÖ Overall Status: GOOD (with suggestions)\n\n`;
      comment += `No critical issues. ${totalWarnings} warning(s) to consider.\n\n`;
    } else {
      comment += `### üéâ Overall Status: EXCELLENT\n\n`;
      comment += `All files follow Supabase best practices!\n\n`;
    }

    comment += `---\n\n`;
    comment += `*Analysis powered by Claude AI | Generated by [Supabase SQL Agent](https://github.com/${this.owner}/${this.repo})*`;

    return comment;
  }

  private formatFileAnalysis(filename: string, result: AnalysisResult): string {
    let section = `### üìÑ \`${filename}\` - Score: **${result.score}/10**\n\n`;

    section += `**Summary:** ${result.summary}\n\n`;

    // Critical Issues
    if (result.critical.length > 0) {
      section += `#### üö® Critical Issues (${result.critical.length})\n\n`;
      result.critical.forEach((issue, idx) => {
        section += `**${idx + 1}.** ${issue.line ? `Line ${issue.line}: ` : ''}${issue.issue}\n`;
        section += `- **Risk:** ${issue.risk}\n`;
        section += `- **Fix:**\n\`\`\`sql\n${issue.fix}\n\`\`\`\n\n`;
      });
    }

    // Warnings
    if (result.warnings.length > 0) {
      section += `#### ‚ö†Ô∏è Warnings (${result.warnings.length})\n\n`;
      result.warnings.forEach((warning, idx) => {
        section += `**${idx + 1}.** ${warning.line ? `Line ${warning.line}: ` : ''}${warning.issue}\n`;
        section += `- **Impact:** ${warning.impact}\n`;
        section += `- **Fix:**\n\`\`\`sql\n${warning.fix}\n\`\`\`\n\n`;
      });
    }

    // Suggestions
    if (result.suggestions.length > 0) {
      section += `#### ‚ÑπÔ∏è Suggestions (${result.suggestions.length})\n\n`;
      result.suggestions.forEach((suggestion, idx) => {
        section += `**${idx + 1}.** ${suggestion.line ? `Line ${suggestion.line}: ` : ''}${suggestion.suggestion}\n`;
        section += `- **Benefit:** ${suggestion.benefit}\n`;
        section += `- **Implementation:**\n\`\`\`sql\n${suggestion.fix}\n\`\`\`\n\n`;
      });
    }

    // Good Practices
    if (result.goodPractices.length > 0) {
      section += `#### ‚úÖ Good Practices Found\n\n`;
      result.goodPractices.forEach((practice) => {
        section += `- ${practice}\n`;
      });
      section += `\n`;
    }

    // Action Plan
    if (result.actionPlan.length > 0) {
      section += `#### üìã Action Plan\n\n`;
      result.actionPlan.forEach((action) => {
        section += `${action}\n`;
      });
      section += `\n`;
    }

    return section;
  }

  async postComment(prNumber: number, results: Map<string, AnalysisResult>): Promise<void> {
    const comment = this.formatAnalysisComment(results);

    try {
      await this.octokit.issues.createComment({
        owner: this.owner,
        repo: this.repo,
        issue_number: prNumber,
        body: comment,
      });

      console.log(`‚úÖ Comment posted to PR #${prNumber}`);
    } catch (error) {
      console.error('‚ùå Error posting comment:', error);
      throw error;
    }
  }
}
