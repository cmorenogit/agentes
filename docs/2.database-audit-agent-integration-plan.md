# Plan de IntegraciÃ³n: Agente AuditorÃ­a BD DinÃ¡mica

**Documento:** Plan completo implementaciÃ³n sistema auditorÃ­a BD
**Proyecto:** Agentes Multi-IA Review System
**Base tÃ©cnica:** `/Users/cmoreno/Code/personal/analisis/docs/Seguridad BD/vFinal-IA_1.md`
**Fecha:** 2025-11-03
**Autor:** Plan generado por anÃ¡lisis exhaustivo arquitectura actual

---

## Tabla de Contenidos

1. [Resumen Ejecutivo](#resumen-ejecutivo)
2. [Arquitectura Actual vs Propuesta](#arquitectura-actual-vs-propuesta)
3. [Archivos a Crear/Modificar](#archivos-a-crearmodificar)
4. [Interfaces y Contratos TypeScript](#interfaces-y-contratos-typescript)
5. [Dependencias y Requisitos](#dependencias-y-requisitos)
6. [Puntos de IntegraciÃ³n](#puntos-de-integraciÃ³n)
7. [Riesgos y Mitigaciones](#riesgos-y-mitigaciones)
8. [EstimaciÃ³n de Esfuerzo](#estimaciÃ³n-de-esfuerzo)
9. [Alternativas Evaluadas](#alternativas-evaluadas)
10. [Plan de ImplementaciÃ³n](#plan-de-implementaciÃ³n)
11. [RecomendaciÃ³n Final](#recomendaciÃ³n-final)
12. [Preguntas Sin Resolver](#preguntas-sin-resolver)
13. [Anexos](#anexos)

---

## Resumen Ejecutivo

### Objetivo

Integrar sistema de **auditorÃ­a de seguridad BD dinÃ¡mica** (basado en vFinal-IA_1.md) en el sistema actual de anÃ¡lisis SQL estÃ¡tico con LLMs mÃºltiples.

### Diferencia CrÃ­tica

**Sistema Actual (AnÃ¡lisis EstÃ¡tico):**
```
Archivos SQL â†’ LLMs leen TEXTO â†’ Analizan lÃ³gica â†’ Comentan issues potenciales
```

**Sistema Propuesto (AuditorÃ­a DinÃ¡mica):**
```
Archivos SQL â†’ Docker PostgreSQL temporal â†’ Carga schema â†’ Ejecuta 14 queries auditorÃ­a â†’ Valida estructura REAL
```

### RelaciÃ³n Entre Ambos

**SON COMPLEMENTARIOS, NO EXCLUYENTES:**

| Aspecto | AnÃ¡lisis LLM (Actual) | AuditorÃ­a BD (Nuevo) |
|---------|----------------------|---------------------|
| **Detecta** | LÃ³gica negocio, convenciones, best practices | Estado estructural REAL (RLS, permisos, policies) |
| **Input** | Texto DDL | Base de datos viva |
| **LimitaciÃ³n** | No ve estado efectivo catÃ¡logos pg_* | No analiza semÃ¡ntica negocio |
| **Output** | Sugerencias mejora cÃ³digo | Findings seguridad bloqueantes |
| **Timing** | 30-60s | 5-10s |
| **Bloqueo PR** | No (informativo) | SÃ­ (crÃ­tico) |

**Ejemplo concreto:**

```sql
-- schema.sql
CREATE TABLE users (id uuid, tenant_id uuid);
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
```

- **LLM detecta:** "Falta Ã­ndice en tenant_id para performance"
- **Audit BD detecta:** "RLS habilitado pero NO FORZADO (relforcerowsecurity=false)"

### ConclusiÃ³n Arquitectural

Sistema hÃ­brido de 2 capas:
1. **Capa 1 (Bloqueante):** AuditorÃ­a estructural BD â†’ Valida seguridad bÃ¡sica
2. **Capa 2 (Informativa):** AnÃ¡lisis semÃ¡ntico LLM â†’ Sugiere mejoras

---

## Arquitectura Actual vs Propuesta

### Arquitectura Actual (Sistema LLM)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GitHub PR Trigger                                           â”‚
â”‚ - Cambios en sql/**/*.sql                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ .github/workflows/sql-review.yml                            â”‚
â”‚ - runs-on: ubuntu-latest                                    â”‚
â”‚ - Node.js 20 + npm ci                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ src/index.ts (Orquestador Principal)                        â”‚
â”‚                                                             â”‚
â”‚ 1. PRHandler.getChangedSQLFiles(prNumber)                  â”‚
â”‚    â†’ Lista archivos modificados: ['sql/schema.sql']        â”‚
â”‚                                                             â”‚
â”‚ 2. SQLReader.readMultipleSQLFiles(files)                   â”‚
â”‚    â†’ Contenido texto de cada archivo                       â”‚
â”‚                                                             â”‚
â”‚ 3. Promise.all([                                           â”‚
â”‚      analyzer.analyze(sql),      // Claude Sonnet 4.5      â”‚
â”‚      openaiAnalyzer.analyze(sql), // GPT-5 (disabled)      â”‚
â”‚      geminiAnalyzer.analyze(sql)  // Gemini 2.5 (disabled) â”‚
â”‚    ])                                                       â”‚
â”‚    â†’ Map<agent, AnalysisResult>                            â”‚
â”‚                                                             â”‚
â”‚ 4. PRCommenter.postComment(prNumber, results)              â”‚
â”‚    â†’ 3 comentarios individuales en PR                      â”‚
â”‚                                                             â”‚
â”‚ 5. GitHubReporter.writeJobSummary(results)                 â”‚
â”‚    â†’ Summary en Actions tab                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Resultado en GitHub PR                                      â”‚
â”‚                                                             â”‚
â”‚ Comentario 1 (Claude):                                      â”‚
â”‚   Score: 8.5/10                                            â”‚
â”‚   - Critical: 1 issue (api_key sin hash)                  â”‚
â”‚   - Warnings: 3 issues                                     â”‚
â”‚   - Suggestions: 5 mejoras                                 â”‚
â”‚                                                             â”‚
â”‚ Comentario 2 (GPT-5): [Disabled]                          â”‚
â”‚ Comentario 3 (Gemini): [Disabled]                         â”‚
â”‚                                                             â”‚
â”‚ Status: âœ… PASS (informativo, no bloquea)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**LIMITACIÃ“N CRÃTICA ACTUAL:**

LLMs solo ven DDL declarativo. **NO pueden verificar:**
- `pg_class.relrowsecurity` (RLS realmente activado)
- `pg_policies` (policies efectivas por rol/operaciÃ³n)
- `pg_default_acl` (permisos heredados automÃ¡ticos)
- `information_schema.role_table_grants` (GRANTS a anon/public)
- `pg_proc.prosecdef` (funciones SECURITY DEFINER inseguras)
- `pg_extension` (extensiones peligrosas activas)
- `version()` (PostgreSQL vulnerable a CVEs)

### Arquitectura Propuesta (Sistema HÃ­brido)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GitHub PR Trigger                                           â”‚
â”‚ - Cambios en sql/**/*.sql                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ .github/workflows/sql-review.yml (MODIFICADO)               â”‚
â”‚ - Step 1: Database Security Audit (NUEVO)                  â”‚
â”‚ - Step 2: LLM Analysis (actual)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FASE 1: AUDITORÃA ESTRUCTURAL (NUEVO)                      â”‚
â”‚ src/audit/db-auditor.ts                                     â”‚
â”‚                                                             â”‚
â”‚ 1. DockerManager.startPostgresContainer()                  â”‚
â”‚    â†’ Docker run postgres:15 en puerto 5433                 â”‚
â”‚    â†’ Espera 5s hasta ready                                 â”‚
â”‚                                                             â”‚
â”‚ 2. loadSchemaIntoDatabase(containerId, 'sql/schema.sql')   â”‚
â”‚    â†’ psql < schema.sql en BD temporal                      â”‚
â”‚    â†’ Maneja errores CREATE EXTENSION, \i includes         â”‚
â”‚                                                             â”‚
â”‚ 3. runSecuritySuite(containerId)                           â”‚
â”‚    â†’ Ejecuta 14 queries de mini_suite_v2.sql              â”‚
â”‚    â†’ Query 1: Tablas sin RLS forzado                      â”‚
â”‚    â†’ Query 2: Policies triviales (USING true)             â”‚
â”‚    â†’ Query 3: SECURITY DEFINER sin search_path            â”‚
â”‚    â†’ Query 4: tenant_id sin FK a tenants                  â”‚
â”‚    â†’ Query 5: idempotency_key sin UNIQUE                  â”‚
â”‚    â†’ Query 6: Policies storage.objects                    â”‚
â”‚    â†’ Query 7: GRANTS a anon/public                        â”‚
â”‚    â†’ Query 8-14: (ver mini_suite completa)                â”‚
â”‚                                                             â”‚
â”‚ 4. parseQueryResults(rawResults)                           â”‚
â”‚    â†’ CSV â†’ AuditFindings[]                                 â”‚
â”‚    â†’ Mapea a severity (critical/high/medium)              â”‚
â”‚                                                             â”‚
â”‚ 5. generateAuditReport(findings)                           â”‚
â”‚    â†’ AuditReport con summary + findings                   â”‚
â”‚    â†’ passed: true si 0 findings crÃ­ticos                  â”‚
â”‚                                                             â”‚
â”‚ 6. DockerManager.stopContainer(containerId)                â”‚
â”‚    â†’ Cleanup (siempre ejecuta, incluso si falla)          â”‚
â”‚                                                             â”‚
â”‚ Output: AuditReport { passed: false, findings: [...] }    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â†“                    â†“
          [IF AUDIT FAILED]     [IF AUDIT PASSED]
                   â†“                    â†“
           âŒ Block PR          âœ… Continue
           Exit 1                       â†“
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚ FASE 2: ANÃLISIS SEMÃNTICO   â”‚
                             â”‚ src/index.ts (SIN CAMBIOS)   â”‚
                             â”‚                              â”‚
                             â”‚ - Claude analiza lÃ³gica      â”‚
                             â”‚ - GPT/Gemini (si enabled)    â”‚
                             â”‚ - Detecta convenciones       â”‚
                             â”‚ - Sugiere mejoras            â”‚
                             â”‚                              â”‚
                             â”‚ Output: AnalysisResult[]     â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FASE 3: COMENTARIOS COMBINADOS (NUEVO)                     â”‚
â”‚ src/github/combined-commenter.ts                            â”‚
â”‚                                                             â”‚
â”‚ postCombinedAnalysis(prNumber, auditReport, llmResults):   â”‚
â”‚                                                             â”‚
â”‚   Comentario Ãšnico con 2 Secciones:                        â”‚
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ ğŸ”’ DATABASE SECURITY AUDIT                  â”‚          â”‚
â”‚   â”‚ Status: âŒ FAILED (3 critical findings)     â”‚          â”‚
â”‚   â”‚                                             â”‚          â”‚
â”‚   â”‚ Critical Findings:                          â”‚          â”‚
â”‚   â”‚ 1. Tablas sin RLS: users, orders           â”‚          â”‚
â”‚   â”‚    Fix: ALTER TABLE ... FORCE RLS;         â”‚          â”‚
â”‚   â”‚                                             â”‚          â”‚
â”‚   â”‚ 2. GRANTS a anon: public.recognitions      â”‚          â”‚
â”‚   â”‚    Fix: REVOKE ALL ... FROM anon;          â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ ğŸ¤– CLAUDE ANALYSIS (Informativo)            â”‚          â”‚
â”‚   â”‚ Score: 8.5/10                               â”‚          â”‚
â”‚   â”‚                                             â”‚          â”‚
â”‚   â”‚ Suggestions:                                â”‚          â”‚
â”‚   â”‚ - Agregar Ã­ndice en tenant_id              â”‚          â”‚
â”‚   â”‚ - Renombrar created_at â†’ created_at_utc    â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Resultado Final GitHub Actions                              â”‚
â”‚                                                             â”‚
â”‚ IF auditReport.passed === false:                           â”‚
â”‚   â†’ âŒ Workflow FAILED                                      â”‚
â”‚   â†’ PR bloqueado hasta remediaciÃ³n                         â”‚
â”‚                                                             â”‚
â”‚ ELSE:                                                       â”‚
â”‚   â†’ âœ… Workflow PASSED                                      â”‚
â”‚   â†’ PR aprobado (con comentarios LLM informativos)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Flujo Secuencial Detallado

```
1. Developer crea PR modificando sql/schema.sql
   â†“
2. GitHub Actions inicia workflow
   â†“
3. [PASO 1 - CRÃTICO] DB Audit ejecuta (5-10s)
   â”œâ”€â”€ Docker pull postgres:15 (si no cached)
   â”œâ”€â”€ Container up en puerto 5433
   â”œâ”€â”€ psql < schema.sql
   â”œâ”€â”€ Ejecuta 14 queries
   â””â”€â”€ Genera AuditReport
   â†“
4. Â¿AuditReport.passed === true?
   â”‚
   â”œâ”€NOâ”€â†’ âŒ BLOCK PR
   â”‚      â”œâ”€â”€ Post comment con findings
   â”‚      â”œâ”€â”€ Exit 1 (workflow failed)
   â”‚      â””â”€â”€ Developer debe remediar
   â”‚
   â””â”€SÃâ”€â†’ âœ… Continue
         â†“
5. [PASO 2 - INFORMATIVO] LLM Analysis ejecuta (30-60s)
   â”œâ”€â”€ Claude analiza semÃ¡ntica
   â”œâ”€â”€ Genera sugerencias mejora
   â””â”€â”€ AnalysisResult
   â†“
6. [PASO 3] Combined Comment
   â”œâ”€â”€ SecciÃ³n 1: Audit passed âœ…
   â”œâ”€â”€ SecciÃ³n 2: Claude suggestions
   â””â”€â”€ Post single comment
   â†“
7. Workflow completo âœ…
   Developer puede mergear PR
```

---

## Archivos a Crear/Modificar

### Archivos NUEVOS (6 archivos)

#### 1. `src/audit/db-auditor.ts` (Principal)

**PropÃ³sito:** Orquestador auditorÃ­a BD completa

**Interfaz:**
```typescript
export class DatabaseAuditor {
  constructor(
    private dockerManager: DockerManager,
    private config: AuditConfig
  ) {}

  async auditSchema(sqlFilePath: string): Promise<AuditReport>

  private async startPostgresContainer(): Promise<ContainerInfo>
  private async loadSchema(container: ContainerInfo, sqlPath: string): Promise<void>
  private async runSecuritySuite(container: ContainerInfo): Promise<QueryResult[]>
  private async parseResults(rawResults: QueryResult[]): Promise<AuditFindings[]>
  private async stopContainer(containerId: string): Promise<void>
}
```

**LÃ­neas estimadas:** ~250 lÃ­neas

---

#### 2. `src/audit/docker-manager.ts`

**PropÃ³sito:** AbstracciÃ³n Docker API (dockerode)

**Interfaz:**
```typescript
export class DockerManager {
  constructor(private docker: Dockerode) {}

  async startContainer(config: ContainerConfig): Promise<string>
  async execCommand(containerId: string, cmd: string[]): Promise<string>
  async stopContainer(containerId: string): Promise<void>
  async checkDockerAvailable(): Promise<boolean>
  async cleanup(): Promise<void>
}

interface ContainerConfig {
  image: string;           // 'postgres:15'
  env: Record<string, string>;
  ports: Record<string, string>;
  autoRemove: boolean;
}
```

**LÃ­neas estimadas:** ~150 lÃ­neas

---

#### 3. `src/audit/queries/mini_suite_v2.sql`

**PropÃ³sito:** 14 queries auditorÃ­a de vFinal-IA_1.md

**Contenido:** Copiar queries lÃ­neas 78-220 de vFinal-IA_1.md

**Modificaciones necesarias:**
- Formato compatible parsing automatizado
- Quitar `\echo` (comandos psql interactivos)
- Agregar comentarios con metadata:
  ```sql
  -- QUERY_ID: 1
  -- SEVERITY: critical
  -- NAME: Tablas sin RLS forzado
  SELECT n.nspname, c.relname AS table
  FROM pg_class c
  ...
  ```

**LÃ­neas estimadas:** ~300 lÃ­neas

---

#### 4. `src/github/combined-commenter.ts`

**PropÃ³sito:** Comentarios hÃ­bridos (Audit + LLM)

**Interfaz:**
```typescript
export class CombinedCommenter {
  constructor(
    private octokit: Octokit,
    private owner: string,
    private repo: string
  ) {}

  async postCombinedAnalysis(
    prNumber: number,
    auditReport: AuditReport,
    llmResults: Map<string, AnalysisResult>
  ): Promise<void>

  private formatAuditSection(report: AuditReport): string
  private formatLLMSection(results: Map<string, AnalysisResult>): string
  private buildMarkdownComment(sections: string[]): string
}
```

**LÃ­neas estimadas:** ~200 lÃ­neas

---

#### 5. `.github/workflows/security-audit.yml`

**PropÃ³sito:** Workflow dedicado auditorÃ­a BD (alternativo a modificar sql-review.yml)

**Contenido:**
```yaml
name: Database Security Audit

on:
  pull_request:
    paths:
      - 'sql/**/*.sql'
      - 'database/**'
      - 'migrations/**'

jobs:
  audit-db:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Build TypeScript
        run: npm run build

      - name: Run DB Security Audit
        run: npm run audit:db
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}

      - name: Upload Audit Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: db-audit-report
          path: audit-report.json
```

**LÃ­neas:** ~50 lÃ­neas

---

#### 6. `docs/database-audit-system.md`

**PropÃ³sito:** DocumentaciÃ³n usuario final

**Secciones:**
- QuÃ© detecta el audit
- CÃ³mo interpretar findings
- CÃ³mo remediar cada tipo de issue
- ConfiguraciÃ³n whitelist
- Troubleshooting

**LÃ­neas estimadas:** ~400 lÃ­neas

---

### Archivos MODIFICADOS (3 archivos)

#### 1. `src/index.ts`

**Cambios:**

```typescript
// AGREGAR imports
import { DatabaseAuditor } from './audit/db-auditor.js';
import { DockerManager } from './audit/docker-manager.js';
import { CombinedCommenter } from './github/combined-commenter.js';

// MODIFICAR funciÃ³n main()
async function main() {
  const config = getConfig();

  // ========== NUEVO: FASE 1 - AUDITORÃA BD ==========
  console.log('ğŸ”’ Iniciando auditorÃ­a de seguridad BD...');

  const dockerManager = new DockerManager();
  const auditor = new DatabaseAuditor(dockerManager, config.audit);

  let auditReport: AuditReport;
  try {
    // Detectar archivo schema principal
    const schemaPath = config.schemaPath || 'sql/schema.sql';
    auditReport = await auditor.auditSchema(schemaPath);

    console.log(`âœ… AuditorÃ­a completada: ${auditReport.findings.length} findings`);
  } catch (error) {
    console.error('âŒ Error en auditorÃ­a BD:', error);
    process.exit(1);
  }

  // ========== ACTUAL: FASE 2 - ANÃLISIS LLM ==========
  console.log('ğŸ¤– Iniciando anÃ¡lisis LLM...');

  const prHandler = new PRHandler(config.githubToken, config.owner, config.repo);
  const changedFiles = await prHandler.getChangedSQLFiles(config.prNumber);

  // ... resto del cÃ³digo actual (sin cambios)
  const results = await Promise.all([
    analyzer.analyze(...),
    // ...
  ]);

  // ========== NUEVO: FASE 3 - COMENTARIOS COMBINADOS ==========
  const combinedCommenter = new CombinedCommenter(
    octokit,
    config.owner,
    config.repo
  );

  await combinedCommenter.postCombinedAnalysis(
    config.prNumber,
    auditReport,
    results
  );

  // ========== NUEVO: BLOQUEO SI AUDIT FAILED ==========
  if (!auditReport.passed) {
    console.error('âŒ DB Audit FAILED: findings crÃ­ticos detectados');
    console.error(`   - Critical: ${auditReport.summary.critical}`);
    console.error(`   - High: ${auditReport.summary.high}`);
    process.exit(1);
  }

  console.log('âœ… Workflow completado exitosamente');
}
```

**LÃ­neas agregadas:** ~40 lÃ­neas

---

#### 2. `package.json`

**Cambios:**

```json
{
  "scripts": {
    "audit:db": "node dist/audit/db-auditor.js",
    "audit:full": "npm run audit:db && npm start"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.27.3",
    "@octokit/rest": "^21.0.2",
    "dockerode": "^4.0.2",
    "pg": "^8.11.5",
    "csv-parse": "^5.5.6"
  },
  "devDependencies": {
    "@types/dockerode": "^3.3.29",
    "@types/pg": "^8.11.6"
  }
}
```

**LÃ­neas agregadas:** ~10 lÃ­neas

---

#### 3. `.github/workflows/sql-review.yml`

**OpciÃ³n A: Agregar step al workflow actual**

```yaml
jobs:
  review-sql:
    steps:
      # ... steps actuales ...

      # NUEVO STEP (antes de "Run Multi-IA SQL Analysis")
      - name: Database Security Audit
        run: npm run audit:db
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}

      # ... resto steps actuales ...
```

**OpciÃ³n B: Mantener separado (recomendado)**
Usar nuevo workflow `security-audit.yml` independiente.

**LÃ­neas agregadas:** ~6 lÃ­neas (OpciÃ³n A) o 0 (OpciÃ³n B)

---

## Interfaces y Contratos TypeScript

### Core Interfaces

```typescript
// src/audit/types.ts

/**
 * Reporte completo de auditorÃ­a BD
 */
export interface AuditReport {
  timestamp: string;           // ISO 8601
  schemaPath: string;          // 'sql/schema.sql'
  postgresVersion: string;     // '15.3'
  findings: AuditFinding[];
  summary: AuditSummary;
  passed: boolean;             // false si critical > 0 o high > threshold
  executionTimeMs: number;
}

/**
 * Finding individual (1 query detectÃ³ N objetos afectados)
 */
export interface AuditFinding {
  queryId: number;              // 1-14
  queryName: string;            // "Tablas sin RLS forzado"
  severity: 'critical' | 'high' | 'medium' | 'low';
  description: string;          // ExplicaciÃ³n tÃ©cnica
  affectedObjects: AffectedObject[];
  remediation: RemediationStep[];
  references: string[];         // URLs docs, CVEs
}

export interface AffectedObject {
  type: 'table' | 'function' | 'policy' | 'grant' | 'extension';
  schema: string;               // 'public'
  name: string;                 // 'users'
  details: Record<string, any>; // Metadata especÃ­fica
}

export interface RemediationStep {
  order: number;
  description: string;
  sql: string;                  // SQL fix sugerido
  riskLevel: 'safe' | 'test-required' | 'breaking';
}

export interface AuditSummary {
  totalFindings: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
}

/**
 * ConfiguraciÃ³n auditorÃ­a
 */
export interface AuditConfig {
  postgresImage: string;        // 'postgres:15'
  postgresPort: number;         // 5433
  schemaPath: string;           // 'sql/schema.sql'
  queriesPath: string;          // 'src/audit/queries/mini_suite_v2.sql'
  timeout: number;              // 120000 (2min)
  whitelist?: AuditWhitelist;
}

export interface AuditWhitelist {
  tablesWithoutRLS?: string[];          // ['public.config', 'public.migrations']
  tablesWithoutTenantId?: string[];     // ['public.settings']
  grantsToAnon?: GrantWhitelist[];      // [{ table: 'public.health', privilege: 'SELECT' }]
  securityDefinerFunctions?: string[];  // ['public.migrate_data']
}

export interface GrantWhitelist {
  schema: string;
  table: string;
  privilege: string;
  grantee: string;
}

/**
 * Info container Docker
 */
export interface ContainerInfo {
  id: string;
  host: string;     // 'localhost'
  port: number;     // 5433
  database: string; // 'postgres'
  user: string;     // 'postgres'
  password: string; // 'postgres'
}

/**
 * Resultado query SQL raw
 */
export interface QueryResult {
  queryId: number;
  rows: any[];
  fields: string[];
  executionTime: number;
}
```

### Class Signatures Completas

```typescript
// src/audit/db-auditor.ts

export class DatabaseAuditor {
  private dockerManager: DockerManager;
  private config: AuditConfig;
  private pgClient?: Client;

  constructor(dockerManager: DockerManager, config: AuditConfig) {
    this.dockerManager = dockerManager;
    this.config = config;
  }

  /**
   * Ejecuta auditorÃ­a completa del schema
   * @throws {AuditError} Si Docker no disponible o schema invÃ¡lido
   */
  async auditSchema(sqlFilePath: string): Promise<AuditReport> {
    const startTime = Date.now();
    let container: ContainerInfo | null = null;

    try {
      // 1. Validar Docker disponible
      const dockerAvailable = await this.dockerManager.checkDockerAvailable();
      if (!dockerAvailable) {
        throw new AuditError('Docker no disponible en este entorno');
      }

      // 2. Iniciar container PostgreSQL
      console.log('  â†’ Iniciando PostgreSQL temporal...');
      container = await this.startPostgresContainer();

      // 3. Cargar schema
      console.log('  â†’ Cargando schema.sql...');
      await this.loadSchema(container, sqlFilePath);

      // 4. Ejecutar 14 queries auditorÃ­a
      console.log('  â†’ Ejecutando suite seguridad (14 queries)...');
      const rawResults = await this.runSecuritySuite(container);

      // 5. Parsear resultados
      console.log('  â†’ Parseando findings...');
      const findings = await this.parseResults(rawResults);

      // 6. Aplicar whitelist
      const filteredFindings = this.applyWhitelist(findings);

      // 7. Generar reporte
      const report = this.generateReport(filteredFindings, startTime);

      return report;

    } catch (error) {
      console.error('Error en auditorÃ­a:', error);
      throw error;
    } finally {
      // 8. Cleanup SIEMPRE (incluso si falla)
      if (container) {
        await this.stopContainer(container.id);
      }
    }
  }

  private async startPostgresContainer(): Promise<ContainerInfo> { /* ... */ }
  private async loadSchema(container: ContainerInfo, sqlPath: string): Promise<void> { /* ... */ }
  private async runSecuritySuite(container: ContainerInfo): Promise<QueryResult[]> { /* ... */ }
  private async parseResults(rawResults: QueryResult[]): Promise<AuditFinding[]> { /* ... */ }
  private applyWhitelist(findings: AuditFinding[]): AuditFinding[] { /* ... */ }
  private generateReport(findings: AuditFinding[], startTime: number): AuditReport { /* ... */ }
  private async stopContainer(containerId: string): Promise<void> { /* ... */ }
}

// src/audit/docker-manager.ts

export class DockerManager {
  private docker: Dockerode;

  constructor() {
    this.docker = new Dockerode();
  }

  async checkDockerAvailable(): Promise<boolean> {
    try {
      await this.docker.ping();
      return true;
    } catch {
      return false;
    }
  }

  async startContainer(config: {
    image: string;
    env: Record<string, string>;
    ports: Record<string, string>;
  }): Promise<string> { /* ... */ }

  async execCommand(containerId: string, cmd: string[]): Promise<string> { /* ... */ }

  async stopContainer(containerId: string): Promise<void> { /* ... */ }
}

// src/github/combined-commenter.ts

export class CombinedCommenter {
  private octokit: Octokit;
  private owner: string;
  private repo: string;

  constructor(octokit: Octokit, owner: string, repo: string) {
    this.octokit = octokit;
    this.owner = owner;
    this.repo = repo;
  }

  async postCombinedAnalysis(
    prNumber: number,
    auditReport: AuditReport,
    llmResults: Map<string, AnalysisResult>
  ): Promise<void> {
    const comment = this.buildComment(auditReport, llmResults);

    await this.octokit.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: prNumber,
      body: comment
    });
  }

  private buildComment(
    audit: AuditReport,
    llm: Map<string, AnalysisResult>
  ): string {
    const sections: string[] = [];

    // SecciÃ³n 1: Audit Report
    sections.push(this.formatAuditSection(audit));

    // SecciÃ³n 2: LLM Analysis
    sections.push(this.formatLLMSection(llm));

    return sections.join('\n\n---\n\n');
  }

  private formatAuditSection(report: AuditReport): string { /* ... */ }
  private formatLLMSection(results: Map<string, AnalysisResult>): string { /* ... */ }
}
```

---

## Dependencias y Requisitos

### Dependencias NPM Nuevas

```json
{
  "dependencies": {
    "dockerode": "^4.0.2",
    "pg": "^8.11.5",
    "csv-parse": "^5.5.6"
  },
  "devDependencies": {
    "@types/dockerode": "^3.3.29",
    "@types/pg": "^8.11.6"
  }
}
```

**JustificaciÃ³n:**

- **dockerode:** Cliente Docker API para Node.js
  - Permite controlar Docker desde TypeScript
  - Alternativas evaluadas: `docker-cli-js` (mÃ¡s limitado), `execa` + docker CLI (menos robusto)

- **pg:** Cliente PostgreSQL oficial
  - Ejecutar queries contra container temporal
  - Parse resultados en formato estructurado

- **csv-parse:** Parser CSV para resultados queries
  - mini_suite_v2.sql retorna resultados en CSV
  - ConversiÃ³n a objetos TypeScript

### Requisitos Sistema

**GitHub Actions (Ya disponibles):**
- âœ… Docker preinstalado en `ubuntu-latest` runners
- âœ… Node.js 20 via `actions/setup-node@v4`
- âœ… Permisos `pull-requests: write`

**Desarrollo Local:**
- Docker Desktop instalado
- PostgreSQL client tools (psql) - Opcional, solo para testing manual
- Node.js 20+

### Limitaciones Conocidas

**PostgreSQL Extensions:**
- Container base `postgres:15` incluye: uuid-ossp, pgcrypto, pg_stat_statements
- **NO incluye:** vector, postgis, timescaledb, pg_cron
- **SoluciÃ³n:** Crear imagen Docker custom si schema requiere extensions exÃ³ticas

**Schema SQL Complejo:**
- `\i` includes de archivos externos â†’ Requiere preprocessing
- `CREATE EXTENSION IF NOT EXISTS xyz` falla si extension no disponible
- **SoluciÃ³n:** Parser que expande includes y comenta extensions no disponibles

---

## Puntos de IntegraciÃ³n

### 1. Flujo Secuencial Completo

```typescript
// src/index.ts - funciÃ³n main() modificada

async function main() {
  const config = getConfig();
  const startTime = Date.now();

  // ============================================================
  // FASE 1: AUDITORÃA BD (BLOQUEANTE)
  // ============================================================
  console.log('ğŸ”’ FASE 1: AuditorÃ­a seguridad BD');

  const dockerManager = new DockerManager();
  const auditor = new DatabaseAuditor(dockerManager, {
    postgresImage: 'postgres:15',
    postgresPort: 5433,
    schemaPath: config.schemaPath || 'sql/schema.sql',
    queriesPath: 'src/audit/queries/mini_suite_v2.sql',
    timeout: 120000, // 2min
    whitelist: config.auditWhitelist
  });

  let auditReport: AuditReport;
  try {
    auditReport = await auditor.auditSchema(config.schemaPath);

    console.log(`  âœ… AuditorÃ­a completada en ${auditReport.executionTimeMs}ms`);
    console.log(`  ğŸ“Š Findings: ${auditReport.summary.totalFindings} total`);
    console.log(`     - Critical: ${auditReport.summary.critical}`);
    console.log(`     - High: ${auditReport.summary.high}`);
    console.log(`     - Medium: ${auditReport.summary.medium}`);

    // Guardar reporte JSON para artifacts
    await fs.writeFile(
      'audit-report.json',
      JSON.stringify(auditReport, null, 2)
    );

  } catch (error) {
    console.error('âŒ Error fatal en auditorÃ­a BD:', error);
    // Post comment con error
    await postErrorComment(config.prNumber, error);
    process.exit(1);
  }

  // ============================================================
  // FASE 2: ANÃLISIS LLM (INFORMATIVO)
  // ============================================================
  console.log('\nğŸ¤– FASE 2: AnÃ¡lisis semÃ¡ntico LLM');

  const prHandler = new PRHandler(config.githubToken, config.owner, config.repo);
  const changedFiles = await prHandler.getChangedSQLFiles(config.prNumber);

  if (changedFiles.length === 0) {
    console.log('  â„¹ï¸  No hay archivos SQL modificados');
    // Solo publicar audit report
    await postAuditOnlyComment(config.prNumber, auditReport);
    return;
  }

  const sqlReader = new SQLReader();
  const sqlContents = await sqlReader.readMultipleSQLFiles(changedFiles);

  // AnÃ¡lisis LLM en paralelo (cÃ³digo actual, sin cambios)
  const results = new Map<string, AnalysisResult>();

  if (config.agents.claude) {
    const analyzer = new SQLAnalyzer(config.anthropicApiKey);
    const result = await analyzer.analyzeFiles(sqlContents);
    results.set('Claude Sonnet 4.5', result);
  }

  // GPT/Gemini si enabled...

  console.log(`  âœ… AnÃ¡lisis LLM completado`);

  // ============================================================
  // FASE 3: COMENTARIOS COMBINADOS
  // ============================================================
  console.log('\nğŸ’¬ FASE 3: Publicando resultados');

  const combinedCommenter = new CombinedCommenter(
    new Octokit({ auth: config.githubToken }),
    config.owner,
    config.repo
  );

  await combinedCommenter.postCombinedAnalysis(
    config.prNumber,
    auditReport,
    results
  );

  console.log('  âœ… Comentario publicado en PR');

  // ============================================================
  // DECISIÃ“N FINAL: PASS/FAIL
  // ============================================================
  const totalTime = Date.now() - startTime;
  console.log(`\nâ±ï¸  Tiempo total: ${totalTime}ms`);

  if (!auditReport.passed) {
    console.error('\nâŒ WORKFLOW FAILED: DB Audit detectÃ³ findings crÃ­ticos');
    console.error('   Developer debe remediar issues antes de merge');
    process.exit(1);
  }

  console.log('\nâœ… WORKFLOW PASSED: Todos los checks aprobados');
}
```

### 2. Ejemplo Comentario Combinado

```markdown
## ğŸ”’ Database Security Audit

**Status:** âŒ **FAILED** (3 critical findings)

**Execution Time:** 8.3s
**PostgreSQL Version:** 15.3
**Schema Analyzed:** `sql/schema.sql`

---

### ğŸš¨ Critical Findings (3)

#### 1. Tablas sin Row-Level Security forzado

**Severity:** ğŸ”´ CRITICAL
**Risk:** Data leakage entre tenants, acceso no autorizado

**Affected Objects:**
- `public.users`
- `public.orders`
- `public.wallet_ledger`

**Evidence:**
```
nspname | relname
--------|-------------
public  | users
public  | orders
public  | wallet_ledger
```

**Remediation:**
```sql
-- Forzar RLS en tablas multi-tenant
ALTER TABLE public.users FORCE ROW LEVEL SECURITY;
ALTER TABLE public.orders FORCE ROW LEVEL SECURITY;
ALTER TABLE public.wallet_ledger FORCE ROW LEVEL SECURITY;
```

**References:**
- [PostgreSQL RLS Documentation](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)
- [CVE-2023-2454: RLS bypass via SET ROLE](https://www.postgresql.org/support/security/CVE-2023-2454/)

---

#### 2. GRANTS peligrosos a rol anÃ³nimo

**Severity:** ğŸ”´ CRITICAL
**Risk:** Usuario no autenticado puede leer/modificar datos sensibles

**Affected Objects:**
- `public.recognitions` (SELECT, INSERT)
- `public.comments` (SELECT)

**Evidence:**
```
table_name     | privilege_type | grantee
---------------|----------------|--------
recognitions   | SELECT         | anon
recognitions   | INSERT         | anon
comments       | SELECT         | anon
```

**Remediation:**
```sql
-- Revocar permisos anÃ³nimos
REVOKE ALL ON public.recognitions FROM anon;
REVOKE ALL ON public.comments FROM anon;

-- Otorgar solo a usuarios autenticados
GRANT SELECT, INSERT ON public.recognitions TO authenticated;
GRANT SELECT ON public.comments TO authenticated;
```

---

#### 3. Funciones SECURITY DEFINER sin search_path fijo

**Severity:** ğŸ”´ CRITICAL
**Risk:** Trojan function attack, privilege escalation

**Affected Objects:**
- `public.create_wallet_transaction()`
- `public.update_user_balance()`

**Remediation:**
```sql
-- Agregar search_path fijo a funciones
CREATE OR REPLACE FUNCTION public.create_wallet_transaction(...)
RETURNS void
SECURITY DEFINER
SET search_path = public, pg_temp  -- â† AGREGADO
LANGUAGE plpgsql AS $$
BEGIN
  -- cÃ³digo funciÃ³n...
END;
$$;
```

**References:**
- [PostgreSQL SECURITY DEFINER Best Practices](https://www.postgresql.org/docs/current/sql-createfunction.html#SQL-CREATEFUNCTION-SECURITY)

---

### âš ï¸ High Findings (2)

<details>
<summary>4. Tablas con tenant_id sin Foreign Key</summary>

**Affected:** `public.wallet_ledger`, `public.audit_logs`

**Fix:**
```sql
ALTER TABLE public.wallet_ledger
ADD CONSTRAINT fk_wallet_ledger_tenant
FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE;
```
</details>

<details>
<summary>5. idempotency_key sin constraint UNIQUE</summary>

**Affected:** `public.wallet_ledger`

**Fix:**
```sql
ALTER TABLE public.wallet_ledger
ADD CONSTRAINT unique_wallet_tx
UNIQUE (tenant_id, idempotency_key);
```
</details>

---

### ğŸ“Š Audit Summary

| Severity | Count | Status |
|----------|-------|--------|
| ğŸ”´ Critical | 3 | âŒ Must fix |
| ğŸŸ¡ High | 2 | âš ï¸ Recommended |
| ğŸŸ¢ Medium | 0 | âœ… |
| âšª Low | 0 | âœ… |

**Next Steps:**
1. Apply remediation SQL from findings above
2. Test in staging environment
3. Push fixes to this PR
4. Audit will re-run automatically

---

## ğŸ¤– Claude Sonnet 4.5 Analysis

**Score:** 8.5/10

**Analysis completed in:** 42.1s

### âœ… Good Practices Detected

- Proper use of UUIDs for primary keys
- Timestamps include timezone (timestamptz)
- Consistent naming convention (snake_case)
- Index on frequently queried columns (user_id, created_at)

### ğŸ’¡ Suggestions for Improvement

**1. Performance: Missing index on tenant_id**

All queries filter by `tenant_id` but only `users` table has index.

```sql
CREATE INDEX idx_orders_tenant_id ON orders(tenant_id);
CREATE INDEX idx_wallet_ledger_tenant_id ON wallet_ledger(tenant_id);
```

**2. Naming: Timestamp column ambiguity**

Column `created_at` should specify timezone explicitly.

```sql
-- Renombrar para claridad
ALTER TABLE orders RENAME COLUMN created_at TO created_at_utc;
```

**3. Data Integrity: Cascade behavior**

Foreign keys use `ON DELETE CASCADE` - verify if this is intentional for `wallet_ledger`.

Consider `ON DELETE RESTRICT` para prevenir borrado accidental.

---

### ğŸ“ˆ Code Quality Metrics

- **Total lines analyzed:** 847
- **Tables:** 12
- **Functions:** 8
- **Policies:** 6
- **Indexes:** 18

---

**Generated by:** SQL Security Review System v2.0
**Powered by:** Database Auditor + Claude Sonnet 4.5
```

### 3. Exit Codes y Bloqueo PR

```typescript
// src/index.ts - al final de main()

// Determinar exit code
let exitCode = 0;
let exitReason = '';

// Check 1: Audit findings crÃ­ticos
if (auditReport.summary.critical > 0) {
  exitCode = 1;
  exitReason = `DB Audit: ${auditReport.summary.critical} critical findings`;
}

// Check 2: Audit findings high (opcional, configurable)
if (config.blockOnHighFindings && auditReport.summary.high > 0) {
  exitCode = 1;
  exitReason = `DB Audit: ${auditReport.summary.high} high severity findings`;
}

// Check 3: LLM score muy bajo (opcional)
// const avgScore = calculateAverage(results);
// if (avgScore < 5.0) {
//   exitCode = 1;
//   exitReason = `LLM Analysis: score ${avgScore} below threshold`;
// }

if (exitCode !== 0) {
  console.error(`\nâŒ Workflow FAILED: ${exitReason}`);
  console.error('   PR bloqueado hasta remediaciÃ³n');
  process.exit(exitCode);
}

console.log('\nâœ… Workflow PASSED');
process.exit(0);
```

**Comportamiento GitHub Actions:**
- Exit code 1 â†’ Workflow status: âŒ Failed
- PR muestra check rojo: "Database Security Audit â€” Failed"
- Branch protection puede requerir check passed antes de merge

---

## Riesgos y Mitigaciones

### ğŸ”´ RIESGOS CRÃTICOS

#### 1. Complejidad Docker en CI

**Riesgo:**
- Docker puede fallar en GitHub Actions por timeout, disk space, networking
- Container huÃ©rfanos consumen recursos
- Image pull puede fallar intermitentemente

**Probabilidad:** Media (10% runs)
**Impacto:** Alto (workflow bloqueado)

**MitigaciÃ³n:**
```typescript
// src/audit/docker-manager.ts

async startContainer(config: ContainerConfig): Promise<string> {
  const TIMEOUT = 60000; // 1min timeout
  const MAX_RETRIES = 3;

  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      // Pull image con timeout
      await this.pullImageWithTimeout(config.image, TIMEOUT);

      // Start container
      const container = await this.docker.createContainer({
        Image: config.image,
        Env: Object.entries(config.env).map(([k, v]) => `${k}=${v}`),
        HostConfig: {
          PortBindings: config.ports,
          AutoRemove: true,  // â† CRÃTICO: cleanup automÃ¡tico
          Memory: 512 * 1024 * 1024, // Limit 512MB
        },
      });

      await container.start();

      // Health check
      await this.waitForPostgres(container.id, 30000);

      return container.id;

    } catch (error) {
      console.error(`  âš ï¸  Intento ${i + 1}/${MAX_RETRIES} fallÃ³:`, error.message);

      if (i === MAX_RETRIES - 1) {
        throw new DockerError('Docker no disponible tras 3 intentos');
      }

      await this.sleep(2000); // Wait 2s entre retries
    }
  }
}

// Cleanup en finally SIEMPRE
async cleanup() {
  const containers = await this.docker.listContainers({ all: true });
  const auditContainers = containers.filter(c =>
    c.Names.some(n => n.includes('audit_pg'))
  );

  for (const c of auditContainers) {
    try {
      const container = this.docker.getContainer(c.Id);
      await container.stop();
      await container.remove();
    } catch {
      // Ignore errors en cleanup
    }
  }
}
```

**Fallback:**
```typescript
// Si Docker NO disponible, skip audit pero WARN
try {
  const dockerAvailable = await dockerManager.checkDockerAvailable();
  if (!dockerAvailable) {
    console.warn('âš ï¸  Docker no disponible, skipping DB audit');
    console.warn('   Solo se ejecutarÃ¡ anÃ¡lisis LLM');
    // Continue sin audit report
  }
} catch {
  // Continue gracefully
}
```

---

#### 2. Schema SQL No Self-Contained

**Riesgo:**
- `schema.sql` puede incluir archivos externos: `\i migrations/001.sql`
- Extensiones no disponibles: `CREATE EXTENSION vector;`
- Dependencias orden de ejecuciÃ³n: `migrations/` debe ejecutarse en orden

**Probabilidad:** Alta (60% proyectos)
**Impacto:** Alto (audit falla, falsos negativos)

**MitigaciÃ³n:**

```typescript
// src/audit/schema-loader.ts

export class SchemaLoader {
  async loadSchemaIntoDatabase(
    container: ContainerInfo,
    schemaPath: string
  ): Promise<void> {
    // 1. Leer schema.sql
    let schemaContent = await fs.readFile(schemaPath, 'utf-8');

    // 2. Expandir \i includes
    schemaContent = await this.expandIncludes(schemaContent, path.dirname(schemaPath));

    // 3. Comentar extensiones no disponibles
    schemaContent = this.handleExtensions(schemaContent);

    // 4. Crear archivo temporal
    const tempPath = '/tmp/schema_expanded.sql';
    await fs.writeFile(tempPath, schemaContent);

    // 5. Cargar en BD
    const pgClient = new Client({
      host: container.host,
      port: container.port,
      database: container.database,
      user: container.user,
      password: container.password,
    });

    await pgClient.connect();

    try {
      await pgClient.query(schemaContent);
    } catch (error) {
      // Log error pero continue (algunas extensiones pueden fallar)
      console.warn('  âš ï¸  Warning durante carga schema:', error.message);
      // NO throw - algunas queries pueden fallar pero schema core cargarse
    } finally {
      await pgClient.end();
    }
  }

  private async expandIncludes(content: string, baseDir: string): Promise<string> {
    const includeRegex = /\\i\s+(['"]?)(.+?)\1/g;
    let match;

    while ((match = includeRegex.exec(content)) !== null) {
      const includePath = path.join(baseDir, match[2]);
      const includeContent = await fs.readFile(includePath, 'utf-8');
      content = content.replace(match[0], includeContent);
    }

    return content;
  }

  private handleExtensions(content: string): string {
    const availableExtensions = [
      'uuid-ossp',
      'pgcrypto',
      'pg_stat_statements',
      'pg_trgm'
    ];

    // Comentar CREATE EXTENSION no disponibles
    const lines = content.split('\n');
    return lines.map(line => {
      if (line.match(/CREATE EXTENSION.*?(['"`])(.+?)\1/i)) {
        const extName = RegExp.$2;
        if (!availableExtensions.includes(extName)) {
          return `-- [SKIPPED: extension not available] ${line}`;
        }
      }
      return line;
    }).join('\n');
  }
}
```

**DocumentaciÃ³n para usuario:**
```markdown
### Limitaciones Schema SQL

El auditor soporta:
- âœ… DDL estÃ¡ndar PostgreSQL
- âœ… Extensions: uuid-ossp, pgcrypto, pg_stat_statements
- âœ… Includes `\i` (expandidos automÃ¡ticamente)

NO soporta:
- âŒ Extensions exÃ³ticas: vector, postgis, timescaledb
- âŒ Datos seeds (`INSERT INTO`)
- âŒ LÃ³gica procedural compleja

**Workaround:** Si tu schema requiere extensions especiales, crea imagen Docker custom.
```

---

#### 3. False Positives Iniciales

**Riesgo:**
- Primera ejecuciÃ³n puede reportar 20+ findings
- Muchos pueden ser legÃ­timos (ej: tabla `config` sin tenant_id intencionalmente)
- Developer frustrado, deshabilitarÃ¡ audit

**Probabilidad:** Alta (80% proyectos)
**Impacto:** Medio (usabilidad)

**MitigaciÃ³n:**

**1. Whitelist configurable:**

```json
// audit-config.json (en raÃ­z proyecto)
{
  "whitelist": {
    "tablesWithoutRLS": [
      "public.migrations",
      "public.config",
      "public.feature_flags"
    ],
    "tablesWithoutTenantId": [
      "public.global_settings",
      "public.system_logs"
    ],
    "grantsToAnon": [
      {
        "table": "public.health_check",
        "privilege": "SELECT",
        "reason": "Endpoint pÃºblico de health"
      }
    ],
    "securityDefinerFunctions": [
      "public.migrate_schema_v2",
      "public.backfill_data"
    ]
  },
  "severity": {
    "blockOnCritical": true,
    "blockOnHigh": false,
    "blockOnMedium": false
  }
}
```

**2. Modo gradual:**

```typescript
// Primera ejecuciÃ³n: solo reporta, NO bloquea
if (fs.existsSync('audit-config.json')) {
  // Whitelist ya configurada â†’ aplicar bloqueo
  if (!auditReport.passed) {
    process.exit(1);
  }
} else {
  // Primera vez â†’ solo comentar findings, NO bloquear
  console.warn('âš ï¸  audit-config.json no encontrado');
  console.warn('   Ejecutando en modo report-only (no bloqueante)');
  console.warn('   Crea audit-config.json para habilitar bloqueo');
  // Continue sin exit
}
```

**3. DocumentaciÃ³n onboarding:**

```markdown
### Primera EjecuciÃ³n

Al agregar DB Audit por primera vez:

1. **Ejecutar manualmente:**
   ```bash
   npm run audit:db
   ```

2. **Revisar findings:**
   - Â¿Son legÃ­timos? â†’ Remediar SQL
   - Â¿Son falsos positivos? â†’ Agregar a whitelist

3. **Crear whitelist:**
   ```bash
   cp audit-config.example.json audit-config.json
   # Editar con tus excepciones
   ```

4. **Re-ejecutar:**
   ```bash
   npm run audit:db
   ```

5. **Cuando 0 findings legÃ­timos:**
   - Commit audit-config.json
   - Audit ahora bloquearÃ¡ PRs futuros
```

---

### ğŸŸ¡ RIESGOS MEDIOS

#### 4. Overhead Tiempo CI

**Riesgo:**
- Workflow actual: ~45s
- Con DB Audit: ~55-60s (+10-15s)
- Developers pueden quejarse de lentitud

**Probabilidad:** Alta
**Impacto:** Bajo (UX)

**MitigaciÃ³n:**
- Audit solo ejecuta si `sql/**` modificado (ya implementado)
- Docker image cached tras primera ejecuciÃ³n
- Paralelizar audit + LLM (en vez de secuencial)

```yaml
# .github/workflows/sql-review.yml

jobs:
  review-sql:
    steps:
      # Ejecutar Audit y LLM en paralelo
      - name: Run DB Audit
        id: audit
        run: npm run audit:db &

      - name: Run LLM Analysis
        id: llm
        run: npm start &

      - name: Wait for both
        run: wait

      - name: Combine results
        run: npm run combine-results
```

---

#### 5. Mantenimiento Queries

**Riesgo:**
- mini_suite_v2.sql puede desactualizarse
- Nuevos patrones inseguros no detectados
- Queries pueden romper con PostgreSQL 16+

**Probabilidad:** Media
**Impacto:** Medio

**MitigaciÃ³n:**
- Versionar queries: `mini_suite_v2.sql`, `v3.sql`...
- Documentar cada query con rationale
- CI job mensual: test queries contra PostgreSQL latest

---

#### 6. Conflicto review-comments-system.md

**Riesgo:**
- `docs/review-comments-system.md` propone cambios grandes (inline comments, metadata gist)
- Implementar ambos simultÃ¡neamente = complejidad alta

**Probabilidad:** Baja (depende priorizaciÃ³n)
**Impacto:** Alto (refactor)

**MitigaciÃ³n:**
- **Implementar en orden:** DB Audit primero, review-comments despuÃ©s
- DB Audit usa comentarios actuales (simples)
- Review-comments es mejora UX opcional posterior

---

### ğŸŸ¢ RIESGOS BAJOS

#### 7. Dependencias Extras

**Riesgo:**
- +3 dependencies (~2MB)
- npm install +5s

**Probabilidad:** Alta
**Impacto:** Muy bajo

**MitigaciÃ³n:** Ninguna necesaria

---

## EstimaciÃ³n de Esfuerzo

### Breakdown Detallado

#### Fase 1: MVP Funcional (1.5 dÃ­as = 12h)

**Sprint 1.1: Infraestructura Docker (4h)**
- [ ] `src/audit/docker-manager.ts` (2h)
  - startContainer()
  - execCommand()
  - stopContainer()
  - checkDockerAvailable()
- [ ] Tests unitarios DockerManager (1h)
- [ ] Dockerfile custom si necesario (1h)

**Sprint 1.2: Auditor Core (6h)**
- [ ] `src/audit/db-auditor.ts` estructura (1h)
- [ ] loadSchema() con expansiÃ³n \i (2h)
- [ ] runSecuritySuite() (2h)
- [ ] parseResults() + tipos (1h)

**Sprint 1.3: Queries SQL (2h)**
- [ ] Copiar mini_suite_v2.sql de vFinal (0.5h)
- [ ] Adaptar formato parsing (1h)
- [ ] Test manual contra schema dummy (0.5h)

---

#### Fase 2: IntegraciÃ³n (0.5 dÃ­a = 4h)

**Sprint 2.1: Modificar index.ts (2h)**
- [ ] Integrar DatabaseAuditor en main() (1h)
- [ ] Exit codes y bloqueo PR (0.5h)
- [ ] Error handling robusto (0.5h)

**Sprint 2.2: Comentarios Combinados (2h)**
- [ ] `src/github/combined-commenter.ts` (1h)
- [ ] Formato markdown audit report (0.5h)
- [ ] Formato markdown LLM results (0.5h)

---

#### Fase 3: Hardening (1 dÃ­a = 8h)

**Sprint 3.1: Whitelist (3h)**
- [ ] DiseÃ±o `audit-config.json` schema (1h)
- [ ] LÃ³gica applyWhitelist() (1h)
- [ ] Modo gradual primera ejecuciÃ³n (1h)

**Sprint 3.2: Robustez (3h)**
- [ ] Retry logic Docker (1h)
- [ ] Timeout containers (1h)
- [ ] Cleanup en finally (1h)

**Sprint 3.3: DocumentaciÃ³n (2h)**
- [ ] `docs/database-audit-system.md` (1h)
- [ ] README updates (0.5h)
- [ ] Video demo (0.5h)

---

#### Fase 4: Testing Real (0.5 dÃ­a = 4h)

**Sprint 4.1: Testing E2E (4h)**
- [ ] Test contra schema.sql proyecto real (1h)
- [ ] Validar findings legÃ­timos vs falsos positivos (1h)
- [ ] Ajustar queries si necesario (1h)
- [ ] PR demo con findings reales (1h)

---

### Totales

| Fase | Horas | DÃ­as (8h) |
|------|-------|-----------|
| Fase 1: MVP | 12h | 1.5 dÃ­as |
| Fase 2: IntegraciÃ³n | 4h | 0.5 dÃ­as |
| Fase 3: Hardening | 8h | 1 dÃ­a |
| Fase 4: Testing | 4h | 0.5 dÃ­as |
| **TOTAL** | **28h** | **3.5 dÃ­as** |
| **Contingencia 20%** | +5.6h | +0.7 dÃ­as |
| **TOTAL FINAL** | **33.6h** | **~4 dÃ­as** |

---

### Cronograma Realista

**Semana 1:**
- Lunes-Martes: Fase 1 (MVP funcional)
- MiÃ©rcoles AM: Fase 2 (IntegraciÃ³n)
- MiÃ©rcoles PM: Fase 3 inicio (Whitelist)

**Semana 2:**
- Jueves: Fase 3 completar (Hardening + docs)
- Viernes: Fase 4 (Testing + ajustes)

**Entregables:**
- Fin Semana 1: MVP funcional, puede ejecutarse localmente
- Fin Semana 2: Sistema completo, CI/CD integrado, documentado

---

## Alternativas Evaluadas

### OpciÃ³n A: Implementar Sistema Completo (RECOMENDADA)

**DescripciÃ³n:** Todo lo descrito en este documento

**Pros:**
- âœ… MÃ¡xima cobertura seguridad (95% segÃºn vFinal-IA_1.md)
- âœ… DetecciÃ³n automÃ¡tica issues estructurales reales
- âœ… Bloqueo PR antes de merge cÃ³digo inseguro
- âœ… Complementa anÃ¡lisis LLM (no lo reemplaza)
- âœ… PreparaciÃ³n compliance (SOC 2, ISO 27001)

**Contras:**
- âŒ Complejidad Docker (mitigable con retries/fallbacks)
- âŒ 4 dÃ­as desarrollo
- âŒ Posibles false positives iniciales (mitigable con whitelist)
- âŒ +10-15s overhead CI

**CuÃ¡ndo elegir:**
- AplicaciÃ³n multi-tenant en producciÃ³n
- Maneja datos sensibles (PII, financieros)
- Equipo >2 developers escribiendo SQL
- Schema evoluciona frecuentemente
- Compliance requerido

**Esfuerzo:** 4 dÃ­as
**Costo mantenimiento:** Bajo (actualizar queries 1-2 veces/aÃ±o)

---

### OpciÃ³n B: Solo Mejorar Prompt LLM

**DescripciÃ³n:** Agregar instrucciones especÃ­ficas a prompt actual

```typescript
// src/agent/prompt.ts - AGREGAR secciÃ³n

export function getSQLAnalysisPrompt(sql: string): string {
  return `Eres auditor SQL experto. Analiza este schema:

${sql}

**ADEMÃS de tu anÃ¡lisis actual, verifica explÃ­citamente:**

1. Â¿Hay ALTER TABLE ... ENABLE ROW LEVEL SECURITY?
   - Si NO â†’ CRITICAL issue

2. Â¿Hay ALTER TABLE ... FORCE ROW LEVEL SECURITY?
   - Si NO â†’ CRITICAL issue (RLS puede bypassearse)

3. Â¿Hay CREATE POLICY con USING (true)?
   - Si SÃ â†’ CRITICAL issue (policy trivial)

4. Â¿Hay GRANT ... TO anon o public?
   - Si SÃ â†’ CRITICAL issue (permisos peligrosos)

5. Â¿Funciones SECURITY DEFINER tienen SET search_path?
   - Si NO â†’ HIGH issue (trojan function risk)

Responde en formato actual...`;
}
```

**Pros:**
- âœ… 30min implementaciÃ³n
- âœ… Cero infraestructura nueva
- âœ… Sin overhead CI
- âœ… Sin dependencias Docker

**Contras:**
- âŒ LLM sigue sin ver estado REAL catÃ¡logos pg_*
- âŒ No detecta permisos heredados (pg_default_acl)
- âŒ No detecta versiÃ³n PostgreSQL vulnerable
- âŒ No verifica extensiones activas
- âŒ AnÃ¡lisis menos confiable (LLM puede alucinar)
- âŒ No bloqueable (no hay ground truth para exit 1)

**CuÃ¡ndo elegir:**
- Prototipo/MVP sin producciÃ³n
- Equipo 1 developer (review manual viable)
- Schema estable (pocos cambios)
- Sin datos sensibles
- Sin compliance

**Esfuerzo:** 0.5h
**Cobertura:** ~40% (vs 95% OpciÃ³n A)

---

### OpciÃ³n C: Audit Manual Semanal

**DescripciÃ³n:** Script ejecutable localmente, NO en CI/CD

```bash
# scripts/audit-db.sh

#!/bin/bash
set -e

echo "ğŸ”’ Iniciando auditorÃ­a semanal..."

# Levantar PostgreSQL
docker run -d --name audit_pg \
  -e POSTGRES_PASSWORD=postgres \
  -p 5433:5432 postgres:15

sleep 5

# Cargar schema
PGPASSWORD=postgres psql -h localhost -p 5433 -U postgres -d postgres < sql/schema.sql

# Ejecutar mini_suite
PGPASSWORD=postgres psql -h localhost -p 5433 -U postgres -d postgres \
  -f scripts/mini_suite_v2.sql --csv > audit-report.csv

# Mostrar resultados
if grep -q "." audit-report.csv; then
  echo "âŒ FINDINGS DETECTADOS:"
  cat audit-report.csv
  exit 1
fi

echo "âœ… AuditorÃ­a passed"

# Cleanup
docker stop audit_pg
docker rm audit_pg
```

**Uso:**
```bash
# Developer ejecuta manualmente cada viernes
npm run audit:weekly

# O agregar a calendar reminder
```

**Pros:**
- âœ… Sin cambios CI/CD
- âœ… DetecciÃ³n mismos issues que OpciÃ³n A
- âœ… Sin overhead PR workflow
- âœ… 2h implementaciÃ³n

**Contras:**
- âŒ No automatizado (fÃ¡cil olvidar)
- âŒ No bloquea PRs (cÃ³digo inseguro puede mergearse)
- âŒ Requiere disciplina equipo
- âŒ Findings detectados post-merge (mÃ¡s costoso remediar)

**CuÃ¡ndo elegir:**
- Equipo pequeÃ±o disciplinado
- Schema cambia 1-2 veces/mes
- Sin CI/CD maduro
- Como paso intermedio antes OpciÃ³n A

**Esfuerzo:** 2h setup inicial
**Costo mantenimiento:** Alto (requiere disciplina manual)

---

### Comparativa

| Criterio | OpciÃ³n A (Completo) | OpciÃ³n B (Prompt LLM) | OpciÃ³n C (Manual) |
|----------|---------------------|----------------------|-------------------|
| **Cobertura** | 95% | 40% | 95% |
| **Automatizado** | âœ… SÃ­ | âœ… SÃ­ | âŒ No |
| **Bloquea PRs** | âœ… SÃ­ | âŒ No | âŒ No |
| **Esfuerzo setup** | 4 dÃ­as | 0.5h | 2h |
| **Overhead CI** | +10-15s | 0s | 0s |
| **Confiabilidad** | Alta (ground truth) | Media (LLM heurÃ­stica) | Alta (ground truth) |
| **False positives** | Media (whitelist) | Baja | Media (whitelist) |
| **Mantenimiento** | Bajo | Muy bajo | Alto |
| **Compliance ready** | âœ… SÃ­ | âŒ No | âš ï¸ Parcial |

---

### RecomendaciÃ³n por Escenario

**Startup pre-product-market-fit:**
â†’ OpciÃ³n B (prompt LLM mejorado)

**Startup post-PMF con tracciÃ³n:**
â†’ OpciÃ³n C (manual) â†’ migrar a OpciÃ³n A en Q2

**Scale-up (10-50 employees):**
â†’ OpciÃ³n A (completo) inmediatamente

**Enterprise:**
â†’ OpciÃ³n A + auditorÃ­a externa anual

**Este proyecto (sistema multi-tenant, 3 LLMs ya implementados):**
â†’ **OpciÃ³n A** (justificaciÃ³n en secciÃ³n siguiente)

---

## Plan de ImplementaciÃ³n

### Prerequisitos

Antes de empezar:

```bash
# 1. Validar Docker disponible localmente
docker --version
# â†’ Docker version 24.0.0 o superior

# 2. Validar PostgreSQL client (opcional, para testing)
psql --version
# â†’ psql (PostgreSQL) 15.x

# 3. Crear branch feature
cd /Users/cmoreno/Code/personal/agentes
git checkout -b feature/database-audit-system
```

---

### Sprint 1: Infraestructura Base (DÃ­a 1-2)

#### Step 1.1: Setup archivos estructura

```bash
# Crear directorios
mkdir -p src/audit/queries
mkdir -p src/audit/types

# Crear archivos vacÃ­os
touch src/audit/db-auditor.ts
touch src/audit/docker-manager.ts
touch src/audit/schema-loader.ts
touch src/audit/types/index.ts
touch src/audit/queries/mini_suite_v2.sql
touch audit-config.example.json
```

#### Step 1.2: Instalar dependencias

```bash
npm install dockerode@^4.0.2 pg@^8.11.5 csv-parse@^5.5.6
npm install -D @types/dockerode@^3.3.29 @types/pg@^8.11.6
```

#### Step 1.3: Implementar tipos

**Archivo:** `src/audit/types/index.ts`

Copiar interfaces de secciÃ³n "Interfaces y Contratos TypeScript" arriba.

#### Step 1.4: Implementar DockerManager

**Archivo:** `src/audit/docker-manager.ts`

```typescript
import Dockerode from 'dockerode';
import { ContainerInfo } from './types/index.js';

export class DockerManager {
  private docker: Dockerode;

  constructor() {
    this.docker = new Dockerode();
  }

  async checkDockerAvailable(): Promise<boolean> {
    try {
      await this.docker.ping();
      return true;
    } catch {
      return false;
    }
  }

  async startPostgresContainer(): Promise<ContainerInfo> {
    // Implementar segÃºn secciÃ³n "Riesgos y Mitigaciones" #1
    // ...
  }

  async stopContainer(containerId: string): Promise<void> {
    // ...
  }
}
```

#### Step 1.5: Test Docker localmente

```bash
# Test script temporal
cat > test-docker.ts << 'EOF'
import { DockerManager } from './src/audit/docker-manager.js';

async function test() {
  const manager = new DockerManager();

  console.log('Testing Docker...');
  const available = await manager.checkDockerAvailable();
  console.log('Docker available:', available);

  if (available) {
    console.log('Starting container...');
    const container = await manager.startPostgresContainer();
    console.log('Container started:', container.id);

    await new Promise(resolve => setTimeout(resolve, 5000));

    console.log('Stopping container...');
    await manager.stopContainer(container.id);
    console.log('âœ… Test passed');
  }
}

test().catch(console.error);
EOF

npx ts-node test-docker.ts
```

---

### Sprint 2: Auditor Core (DÃ­a 2-3)

#### Step 2.1: Copiar mini_suite_v2.sql

```bash
# Copiar desde vFinal-IA_1.md lÃ­neas 78-220
# Adaptar formato para parsing
cat > src/audit/queries/mini_suite_v2.sql << 'EOF'
-- QUERY_ID: 1
-- SEVERITY: critical
-- NAME: Tablas sin RLS forzado
SELECT n.nspname, c.relname AS table
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'r'
  AND n.nspname = 'public'
  AND (c.relrowsecurity = false OR c.relforcerowsecurity = false);

-- QUERY_ID: 2
-- SEVERITY: critical
-- NAME: Policies triviales
SELECT schemaname, tablename, policyname, cmd, qual, with_check
FROM pg_policies
WHERE qual ~* '^\s*true\s*$' OR with_check ~* '^\s*true\s*$';

-- ... (resto 12 queries)
EOF
```

#### Step 2.2: Implementar DatabaseAuditor

**Archivo:** `src/audit/db-auditor.ts`

Implementar segÃºn class signature en secciÃ³n "Interfaces y Contratos TypeScript".

Key methods:
- `auditSchema()` - Orquestador principal
- `loadSchema()` - Usa SchemaLoader para cargar SQL
- `runSecuritySuite()` - Ejecuta mini_suite_v2.sql
- `parseResults()` - CSV â†’ AuditFinding[]

#### Step 2.3: Test end-to-end local

```bash
# Crear schema dummy para testing
cat > test-schema.sql << 'EOF'
CREATE TABLE users (
  id uuid PRIMARY KEY,
  tenant_id uuid NOT NULL,
  email text NOT NULL
);

-- Intencionalmente INSEGURO (sin RLS)
-- Debe detectarse en audit
EOF

# Test auditor
cat > test-auditor.ts << 'EOF'
import { DatabaseAuditor } from './src/audit/db-auditor.js';
import { DockerManager } from './src/audit/docker-manager.js';

async function test() {
  const manager = new DockerManager();
  const auditor = new DatabaseAuditor(manager, {
    postgresImage: 'postgres:15',
    postgresPort: 5433,
    schemaPath: 'test-schema.sql',
    queriesPath: 'src/audit/queries/mini_suite_v2.sql',
    timeout: 120000
  });

  console.log('Running audit...');
  const report = await auditor.auditSchema('test-schema.sql');

  console.log('\nğŸ“Š AUDIT REPORT:');
  console.log('Findings:', report.findings.length);
  console.log('Passed:', report.passed);
  console.log('\nFindings:');
  report.findings.forEach(f => {
    console.log(`  - [${f.severity}] ${f.queryName}`);
    console.log(`    Affected: ${f.affectedObjects.map(o => o.name).join(', ')}`);
  });

  if (report.findings.length === 0) {
    console.error('âŒ Test FAILED: Expected findings pero encontrÃ³ 0');
    process.exit(1);
  }

  console.log('\nâœ… Test PASSED');
}

test().catch(console.error);
EOF

npx ts-node test-auditor.ts
```

**Resultado esperado:**
```
Running audit...
  â†’ Iniciando PostgreSQL temporal...
  â†’ Cargando schema.sql...
  â†’ Ejecutando suite seguridad (14 queries)...
  â†’ Parseando findings...

ğŸ“Š AUDIT REPORT:
Findings: 3
Passed: false

Findings:
  - [critical] Tablas sin RLS forzado
    Affected: users
  - [critical] GRANTS peligrosos a anon
    Affected: users
  - [high] Tablas con tenant_id sin FK
    Affected: users

âœ… Test PASSED
```

---

### Sprint 3: IntegraciÃ³n Main (DÃ­a 3-4)

#### Step 3.1: Implementar CombinedCommenter

**Archivo:** `src/github/combined-commenter.ts`

Implementar segÃºn secciÃ³n "Puntos de IntegraciÃ³n" #2 (ejemplo comentario combinado).

#### Step 3.2: Modificar index.ts

Aplicar cambios segÃºn secciÃ³n "Archivos a Modificar" #1.

#### Step 3.3: Actualizar package.json

```json
{
  "scripts": {
    "audit:db": "node dist/audit/cli.js"
  }
}
```

**Crear:** `src/audit/cli.ts` (script CLI para npm run)

```typescript
import { DatabaseAuditor } from './db-auditor.js';
import { DockerManager } from './docker-manager.js';

async function main() {
  const config = {
    postgresImage: 'postgres:15',
    postgresPort: 5433,
    schemaPath: process.env.SCHEMA_PATH || 'sql/schema.sql',
    queriesPath: 'src/audit/queries/mini_suite_v2.sql',
    timeout: 120000
  };

  const manager = new DockerManager();
  const auditor = new DatabaseAuditor(manager, config);

  const report = await auditor.auditSchema(config.schemaPath);

  // Write JSON report
  await fs.writeFile(
    'audit-report.json',
    JSON.stringify(report, null, 2)
  );

  if (!report.passed) {
    console.error('âŒ Audit FAILED');
    process.exit(1);
  }

  console.log('âœ… Audit PASSED');
}

main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
```

#### Step 3.4: Build y test

```bash
npm run build
npm run audit:db
```

---

### Sprint 4: Whitelist y Hardening (DÃ­a 4-5)

#### Step 4.1: Crear audit-config.example.json

```json
{
  "$schema": "https://json-schema.org/draft-07/schema#",
  "whitelist": {
    "tablesWithoutRLS": [
      "public.migrations",
      "public.config"
    ],
    "tablesWithoutTenantId": [
      "public.global_settings"
    ],
    "grantsToAnon": [
      {
        "table": "public.health_check",
        "privilege": "SELECT",
        "reason": "Health endpoint pÃºblico"
      }
    ]
  },
  "severity": {
    "blockOnCritical": true,
    "blockOnHigh": false
  }
}
```

#### Step 4.2: Implementar lÃ³gica whitelist

En `DatabaseAuditor.applyWhitelist()`:

```typescript
private applyWhitelist(findings: AuditFinding[]): AuditFinding[] {
  if (!this.config.whitelist) {
    return findings;
  }

  return findings.filter(finding => {
    // Query 1: Tablas sin RLS
    if (finding.queryId === 1) {
      const whitelisted = this.config.whitelist.tablesWithoutRLS || [];
      finding.affectedObjects = finding.affectedObjects.filter(obj =>
        !whitelisted.includes(`${obj.schema}.${obj.name}`)
      );
      return finding.affectedObjects.length > 0;
    }

    // Query 4: Tablas sin tenant_id FK
    if (finding.queryId === 4) {
      const whitelisted = this.config.whitelist.tablesWithoutTenantId || [];
      finding.affectedObjects = finding.affectedObjects.filter(obj =>
        !whitelisted.includes(`${obj.schema}.${obj.name}`)
      );
      return finding.affectedObjects.length > 0;
    }

    // ... resto queries
    return true;
  });
}
```

#### Step 4.3: Modo gradual primera ejecuciÃ³n

Ver secciÃ³n "Riesgos y Mitigaciones" #3.

---

### Sprint 5: Workflow CI/CD (DÃ­a 5)

#### Step 5.1: Actualizar .github/workflows/sql-review.yml

Agregar step audit segÃºn secciÃ³n "Archivos a Modificar" #3.

#### Step 5.2: Test en PR real

```bash
# Commit cambios
git add .
git commit -m "feat: Add database security audit system"
git push origin feature/database-audit-system

# Crear PR
gh pr create --title "Add Database Security Audit" \
  --body "Implementa auditorÃ­a BD dinÃ¡mica segÃºn vFinal-IA_1.md"
```

#### Step 5.3: Validar workflow

- Ver Actions tab: workflow ejecutÃ¡ndose
- Verificar Docker container start/stop
- Verificar comentario combinado en PR
- Validar exit code si findings

---

### Sprint 6: DocumentaciÃ³n (DÃ­a 5)

#### Step 6.1: Crear docs/database-audit-system.md

Incluir:
- QuÃ© detecta cada query
- CÃ³mo interpretar findings
- GuÃ­a remediaciÃ³n
- ConfiguraciÃ³n whitelist
- Troubleshooting

#### Step 6.2: Actualizar README.md

Agregar secciÃ³n:
```markdown
## Database Security Audit

Este proyecto incluye auditorÃ­a automÃ¡tica de seguridad BD que ejecuta en cada PR.

### QuÃ© Detecta

- Tablas sin RLS forzado
- Policies triviales (USING true)
- GRANTS peligrosos a anon/public
- ... (ver docs/database-audit-system.md)

### ConfiguraciÃ³n

Ver `audit-config.example.json` para whitelist.
```

#### Step 6.3: Video demo (opcional)

Grabar screencast:
1. Crear PR con schema inseguro
2. Audit detecta findings
3. Remediar SQL
4. Audit pasa

---

## RecomendaciÃ³n Final

### Para Este Proyecto: IMPLEMENTAR OPCIÃ“N A (Completo)

**JustificaciÃ³n tÃ©cnica:**

1. **Sistema multi-tenant crÃ­tico:**
   - CÃ³digo existente maneja `tenant_id` en mÃºltiples tablas
   - RLS mal configurado = data leakage catastrÃ³fico
   - Costo breach >> costo implementaciÃ³n (4 dÃ­as)

2. **Infraestructura CI madura:**
   - Ya tienen 3 LLMs integrados en workflow
   - Docker en GitHub Actions viable (ya lo usan implÃ­citamente)
   - Equipo familiarizado con TypeScript + GitHub Actions

3. **Gaps crÃ­ticos actuales:**
   - LLMs NO pueden verificar `pg_class.relrowsecurity` real
   - Permisos heredados invisibles en schema.sql
   - CVE PostgreSQL no detectables sin version()

4. **ROI claro:**
   - InversiÃ³n: 4 dÃ­as desarrollo
   - Beneficio: PrevenciÃ³n 100% data leaks estructurales
   - Compliance-ready (SOC 2 check pre-aprobado)

5. **Complementa sistema actual:**
   - NO reemplaza LLMs (son complementarios)
   - Audit = bloqueante (seguridad)
   - LLM = informativo (calidad)

---

### Orden de ImplementaciÃ³n

**Prioridad 1 (Ahora):**
- âœ… Database Audit System (este plan)

**Prioridad 2 (DespuÃ©s Q1):**
- â¸ï¸ Review Comments System (docs/review-comments-system.md)
  - Inline comments en lÃ­neas especÃ­ficas
  - Metadata Gist para tracking
  - Re-evaluaciÃ³n granular

**Prioridad 3 (Q2):**
- â¸ï¸ Penetration Tests Automatizados (vFinal lÃ­neas 387-412)
- â¸ï¸ Monitoring pgaudit (vFinal lÃ­neas 497-525)

**RazÃ³n orden:**
Audit BD es fundacional. Review-comments es mejora UX que puede esperar.

---

### Criterio Go/No-Go

**IMPLEMENTAR SI:**
- âœ… Maneja datos multi-tenant en producciÃ³n
- âœ… >1 developer escribiendo SQL
- âœ… Schema cambia >1 vez/mes
- âœ… Compliance (SOC 2/ISO 27001) requerido o planeado
- âœ… Budget 4 dÃ­as disponible

**POSTPONER SI:**
- âŒ Prototipo pre-producciÃ³n
- âŒ Solo 1 developer (review manual viable)
- âŒ Schema estable (0-1 cambios/trimestre)
- âŒ Sin datos sensibles
- âŒ Prioridad features > seguridad

**ESTE PROYECTO:**
âœ… Cumple 5/5 criterios â†’ **IMPLEMENTAR**

---

### Rollout Strategy

**Fase Alpha (Semana 1):**
- Implementar en feature branch
- Test contra schema actual
- Configurar whitelist para 0 false positives
- Demo interno equipo

**Fase Beta (Semana 2):**
- Merge a main en modo report-only (no bloqueante)
- Observar findings reales en prÃ³ximos 5 PRs
- Ajustar whitelist segÃºn feedback

**Fase GA (Semana 3):**
- Habilitar modo bloqueante (`blockOnCritical: true`)
- Comunicar a equipo nueva polÃ­tica
- Monitorear tasa bloqueo PRs (target <10%)

**Fase Improvement (Mes 2+):**
- Agregar queries custom especÃ­ficas proyecto
- Configurar alertas findings recurrentes
- Documentar lecciones aprendidas

---

## Preguntas Sin Resolver

Antes de iniciar implementaciÃ³n, clarificar:

### 1. Estructura Schema SQL

**Pregunta:** Â¿CÃ³mo estÃ¡ organizado tu schema?

**Opciones:**
- A) Archivo Ãºnico: `sql/schema.sql`
- B) MÃºltiples migrations: `migrations/001_init.sql`, `002_add_rls.sql`, ...
- C) Supabase structure: `supabase/migrations/*.sql`

**Impacto:**
- OpciÃ³n A â†’ ImplementaciÃ³n directa
- OpciÃ³n B â†’ Necesita merge logic (concatenar en orden)
- OpciÃ³n C â†’ Path diferente en workflow

---

### 2. Extensiones PostgreSQL Requeridas

**Pregunta:** Â¿QuÃ© extensiones usa tu schema?

**Common:**
- uuid-ossp (UUID generation) â†’ âœ… Incluida en postgres:15
- pgcrypto (hashing) â†’ âœ… Incluida
- pg_stat_statements (monitoring) â†’ âœ… Incluida

**ExÃ³ticas:**
- vector (embeddings) â†’ âŒ Requiere imagen custom
- postgis (geospatial) â†’ âŒ Requiere imagen custom
- timescaledb â†’ âŒ Requiere imagen custom

**Impacto:**
Si usas extensiones exÃ³ticas, necesitas:
```dockerfile
# Dockerfile.audit-postgres
FROM postgres:15
RUN apt-get update && apt-get install -y postgresql-15-postgis-3
```

---

### 3. Whitelist Inicial Conocida

**Pregunta:** Â¿Hay tablas que intencionalmente NO tienen RLS/tenant_id?

**Ejemplos:**
- `public.migrations` (Django/Rails migrations table)
- `public.config` (Global settings)
- `public.feature_flags` (Shared across tenants)
- `public.system_logs` (No tenant-scoped)

**Impacto:**
Pre-configurar `audit-config.json` para evitar false positives iniciales.

---

### 4. Nivel de Bloqueo PR

**Pregunta:** Â¿QuÃ© severidad debe bloquear el PR?

**Opciones:**
- A) Solo CRITICAL (recomendado para inicio)
- B) CRITICAL + HIGH
- C) CRITICAL + HIGH + MEDIUM (muy estricto)

**Impacto:**
```json
{
  "severity": {
    "blockOnCritical": true,
    "blockOnHigh": false  // â† CONFIGURAR
  }
}
```

---

### 5. IntegraciÃ³n review-comments-system.md

**Pregunta:** Â¿Quieres implementar ambos simultÃ¡neamente?

**Opciones:**
- A) Solo DB Audit ahora (recomendado)
- B) DB Audit + review-comments juntos (arriesgado)
- C) review-comments ahora, DB Audit despuÃ©s (no recomendado)

**Impacto:**
- OpciÃ³n A: 4 dÃ­as, bajo riesgo
- OpciÃ³n B: 6-7 dÃ­as, alto riesgo complejidad
- OpciÃ³n C: Pierde prioridad seguridad

---

## Anexos

### Anexo A: Ejemplo Docker Setup Completo

```typescript
// src/audit/docker-manager.ts - ImplementaciÃ³n producciÃ³n

import Dockerode from 'dockerode';
import { ContainerInfo } from './types/index.js';

export class DockerManager {
  private docker: Dockerode;
  private readonly POSTGRES_PORT = 5433;
  private readonly TIMEOUT = 60000;

  constructor() {
    this.docker = new Dockerode();
  }

  async startPostgresContainer(): Promise<ContainerInfo> {
    console.log('  â†’ Pulling postgres:15 image...');
    await this.pullImage('postgres:15');

    console.log('  â†’ Creating container...');
    const container = await this.docker.createContainer({
      Image: 'postgres:15',
      Env: ['POSTGRES_PASSWORD=postgres'],
      HostConfig: {
        PortBindings: {
          '5432/tcp': [{ HostPort: String(this.POSTGRES_PORT) }]
        },
        AutoRemove: true,
        Memory: 512 * 1024 * 1024, // 512MB limit
      },
      name: `audit_pg_${Date.now()}`,
    });

    console.log('  â†’ Starting container...');
    await container.start();

    // Wait for PostgreSQL ready
    console.log('  â†’ Waiting for PostgreSQL ready...');
    await this.waitForPostgres(container.id, 30000);

    return {
      id: container.id,
      host: 'localhost',
      port: this.POSTGRES_PORT,
      database: 'postgres',
      user: 'postgres',
      password: 'postgres',
    };
  }

  private async pullImage(image: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.docker.pull(image, (err: any, stream: any) => {
        if (err) return reject(err);

        this.docker.modem.followProgress(stream, (err: any) => {
          if (err) return reject(err);
          resolve();
        });

        // Timeout
        setTimeout(() => {
          reject(new Error('Image pull timeout'));
        }, this.TIMEOUT);
      });
    });
  }

  private async waitForPostgres(
    containerId: string,
    timeout: number
  ): Promise<void> {
    const startTime = Date.now();

    while (Date.now() - startTime < timeout) {
      try {
        const { Client } = await import('pg');
        const client = new Client({
          host: 'localhost',
          port: this.POSTGRES_PORT,
          database: 'postgres',
          user: 'postgres',
          password: 'postgres',
        });

        await client.connect();
        await client.query('SELECT 1');
        await client.end();

        console.log('  âœ… PostgreSQL ready');
        return;

      } catch {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error('PostgreSQL startup timeout');
  }

  async stopContainer(containerId: string): Promise<void> {
    try {
      const container = this.docker.getContainer(containerId);
      await container.stop({ t: 5 }); // 5s graceful shutdown
      // AutoRemove=true â†’ container auto-deleted
    } catch (error) {
      // Ignore errors (container may already be stopped)
      console.warn('  âš ï¸  Error stopping container:', error.message);
    }
  }

  async cleanup(): Promise<void> {
    const containers = await this.docker.listContainers({ all: true });
    const auditContainers = containers.filter(c =>
      c.Names.some(n => n.includes('audit_pg'))
    );

    for (const c of auditContainers) {
      try {
        const container = this.docker.getContainer(c.Id);
        await container.stop();
        await container.remove();
      } catch {
        // Ignore
      }
    }
  }
}
```

### Anexo B: Ejemplo Query Mini Suite

```sql
-- src/audit/queries/mini_suite_v2.sql
-- Basado en vFinal-IA_1.md

-- =============================================================================
-- QUERY 1: Tablas sin RLS forzado
-- =============================================================================
-- QUERY_ID: 1
-- SEVERITY: critical
-- NAME: Tablas sin RLS forzado
-- REMEDIATION: ALTER TABLE {{schema}}.{{table}} FORCE ROW LEVEL SECURITY;

SELECT
  n.nspname AS schema,
  c.relname AS table,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'r'
  AND n.nspname = 'public'
  AND (c.relrowsecurity = false OR c.relforcerowsecurity = false);

-- =============================================================================
-- QUERY 2: Policies triviales
-- =============================================================================
-- QUERY_ID: 2
-- SEVERITY: critical
-- NAME: Policies triviales (USING true / WITH CHECK true)
-- REMEDIATION: Reescribir policy con filtro tenant_id real

SELECT
  schemaname,
  tablename,
  policyname,
  cmd,
  qual,
  with_check
FROM pg_policies
WHERE qual ~* '^\s*true\s*$' OR with_check ~* '^\s*true\s*$';

-- =============================================================================
-- QUERY 3: Funciones SECURITY DEFINER sin search_path fijo
-- =============================================================================
-- QUERY_ID: 3
-- SEVERITY: critical
-- NAME: Funciones SECURITY DEFINER sin search_path fijo
-- REMEDIATION: SET search_path = public, pg_temp en definiciÃ³n funciÃ³n

SELECT
  n.nspname AS schema,
  p.proname AS function_name,
  p.prosecdef AS is_security_definer,
  p.proconfig AS config
FROM pg_proc p
JOIN pg_namespace n ON n.oid = p.pronamespace
WHERE p.prosecdef = true
  AND (p.proconfig IS NULL OR NOT (p.proconfig::text ~* 'search_path'));

-- ... (continuar con queries 4-14)
```

### Anexo C: Formato Audit Report JSON

```json
{
  "timestamp": "2025-11-03T14:32:18.123Z",
  "schemaPath": "sql/schema.sql",
  "postgresVersion": "PostgreSQL 15.3",
  "executionTimeMs": 8342,
  "findings": [
    {
      "queryId": 1,
      "queryName": "Tablas sin RLS forzado",
      "severity": "critical",
      "description": "RLS no estÃ¡ forzado en estas tablas, permitiendo bypass vÃ­a SET ROLE",
      "affectedObjects": [
        {
          "type": "table",
          "schema": "public",
          "name": "users",
          "details": {
            "rls_enabled": true,
            "rls_forced": false
          }
        },
        {
          "type": "table",
          "schema": "public",
          "name": "orders",
          "details": {
            "rls_enabled": false,
            "rls_forced": false
          }
        }
      ],
      "remediation": [
        {
          "order": 1,
          "description": "Forzar RLS en tabla users",
          "sql": "ALTER TABLE public.users FORCE ROW LEVEL SECURITY;",
          "riskLevel": "safe"
        },
        {
          "order": 2,
          "description": "Habilitar y forzar RLS en tabla orders",
          "sql": "ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.orders FORCE ROW LEVEL SECURITY;",
          "riskLevel": "safe"
        }
      ],
      "references": [
        "https://www.postgresql.org/docs/current/ddl-rowsecurity.html",
        "https://www.postgresql.org/support/security/CVE-2023-2454/"
      ]
    },
    {
      "queryId": 7,
      "queryName": "GRANTS peligrosos a anon/public",
      "severity": "critical",
      "description": "Roles anÃ³nimos tienen permisos sobre tablas sensibles",
      "affectedObjects": [
        {
          "type": "grant",
          "schema": "public",
          "name": "recognitions",
          "details": {
            "privilege": "SELECT",
            "grantee": "anon"
          }
        }
      ],
      "remediation": [
        {
          "order": 1,
          "description": "Revocar permisos anÃ³nimos",
          "sql": "REVOKE ALL ON public.recognitions FROM anon;",
          "riskLevel": "test-required"
        },
        {
          "order": 2,
          "description": "Otorgar a authenticated solamente",
          "sql": "GRANT SELECT, INSERT ON public.recognitions TO authenticated;",
          "riskLevel": "test-required"
        }
      ],
      "references": [
        "https://supabase.com/docs/guides/auth/row-level-security"
      ]
    }
  ],
  "summary": {
    "totalFindings": 2,
    "critical": 2,
    "high": 0,
    "medium": 0,
    "low": 0
  },
  "passed": false
}
```

### Anexo D: Ejemplo Whitelist Config

```json
{
  "$schema": "https://json-schema.org/draft-07/schema#",
  "title": "Database Audit Whitelist Configuration",
  "description": "Excepciones legÃ­timas a queries de auditorÃ­a",

  "whitelist": {
    "tablesWithoutRLS": [
      "public.migrations",
      "public.django_migrations",
      "public.config",
      "public.feature_flags",
      "public.system_logs"
    ],

    "tablesWithoutTenantId": [
      "public.global_settings",
      "public.audit_logs",
      "public.health_check"
    ],

    "grantsToAnon": [
      {
        "schema": "public",
        "table": "health_check",
        "privilege": "SELECT",
        "grantee": "anon",
        "reason": "Health endpoint pÃºblico para load balancer"
      },
      {
        "schema": "public",
        "table": "public_profiles",
        "privilege": "SELECT",
        "grantee": "public",
        "reason": "Perfiles pÃºblicos visibles sin autenticaciÃ³n"
      }
    ],

    "securityDefinerFunctions": [
      "public.migrate_schema_v2",
      "public.backfill_tenant_data",
      "public.system_maintenance"
    ],

    "policiesTrivial": [
      {
        "schema": "public",
        "table": "feature_flags",
        "policyName": "allow_all_read",
        "reason": "Tabla no tiene datos sensibles, lectura pÃºblica OK"
      }
    ]
  },

  "severity": {
    "blockOnCritical": true,
    "blockOnHigh": false,
    "blockOnMedium": false,
    "warnOnLow": true
  },

  "notifications": {
    "slackWebhook": null,
    "emailOnFail": []
  }
}
```

---

## ConclusiÃ³n

Este plan proporciona:

1. âœ… **AnÃ¡lisis exhaustivo** arquitectura actual
2. âœ… **DiseÃ±o detallado** sistema hÃ­brido (Audit + LLM)
3. âœ… **Interfaces completas** TypeScript con ejemplos
4. âœ… **Riesgos identificados** con mitigaciones concretas
5. âœ… **EstimaciÃ³n realista** 4 dÃ­as (no optimista)
6. âœ… **Plan ejecuciÃ³n** sprint-by-sprint accionable
7. âœ… **Alternativas evaluadas** honestamente
8. âœ… **RecomendaciÃ³n final** justificada tÃ©cnicamente

**PrÃ³ximo paso:**

Responder 5 preguntas sin resolver â†’ Iniciar Sprint 1

**Contacto para dudas:** (agregar si aplica)

---

**Fin del documento**
Ãšltima actualizaciÃ³n: 2025-11-03
